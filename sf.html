
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Special functions &#8212; GSL Shell 2.3.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Monte Carlo Integration" href="vegas.html" />
    <link rel="prev" title="Numerical Integration" href="integ.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vegas.html" title="Monte Carlo Integration"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="integ.html" title="Numerical Integration"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GSL Shell 2.3.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Special functions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="special-functions">
<span id="id1"></span><h1>Special functions<a class="headerlink" href="#special-functions" title="Permalink to this headline">¶</a></h1>
<p>The library includes routines for calculating the values of Airy functions, Bessel functions, Clausen functions, Coulomb wave functions, Coupling coefficients, the Dawson function, Debye functions, Dilogarithms, Elliptic integrals, Jacobi elliptic functions, Error functions, Exponential integrals, Fermi-Dirac functions, Gamma functions, Gegenbauer functions, Hypergeometric functions, Laguerre functions, Legendre functions and Spherical Harmonics, the Psi (Digamma) Function, Synchrotron functions, Transport functions, Trigonometric functions and Zeta functions.
Any error returned by the special function (such as invalid input domains, etc…) will be signaled.</p>
<section id="module-sf">
<span id="overview"></span><h2>Overview<a class="headerlink" href="#module-sf" title="Permalink to this headline">¶</a></h2>
<section id="airy-functions">
<h3>Airy Functions<a class="headerlink" href="#airy-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi" title="Permalink to this definition">¶</a></dt>
<dd><p>The Airy functions <span class="math notranslate nohighlight">\(Ai(x)\)</span> and <span class="math notranslate nohighlight">\(Bi(x)\)</span> are defined by the integral representations,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}Ai(x) = {1 \over \pi} \int_0^\infty \cos({1 \over 3} t^3 + xt) dt\\Bi(x) = {1 \over \pi} \int_0^\infty \left( e^{-{1 \over 3} t^3} + \sin(1/3 \, t^3 + xt) \right) dt\end{aligned}\end{align} \]</div>
<p>For further information see Abramowitz &amp; Stegun, Section 10.4.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_scaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute a scaled version of the Airy function <span class="math notranslate nohighlight">\(S_A(x) Ai(x)\)</span>.
For x&gt;0 the scaling factor <span class="math notranslate nohighlight">\(S_A(x)\)</span> is</p>
<div class="math notranslate nohighlight">
\[\exp(+(2/3) x^(3/2))\]</div>
<p>and is 1 for x&lt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv_scaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Airy function derivatives and their scaled version with the same scaling factor as the airyAi_scaled and airyBi_scaled versions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the n-th zero of the respective functions or their derivatives.</p>
<figure class="align-default" id="id6">
<img alt="_images/examples-airy-functions-plot.png" src="_images/examples-airy-functions-plot.png" />
<figcaption>
<p><span class="caption-text">Airy functions Ai and Bi.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

</section>
<section id="bessel-functions">
<h3>Bessel Functions<a class="headerlink" href="#bessel-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.besselJ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselJ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of
n-th order, J<sub>n</sub>(x)</p>
<figure class="align-default" id="id7">
<img alt="_images/sf-besselJ-functions.png" src="_images/sf-besselJ-functions.png" />
<figcaption>
<p><span class="caption-text">Bessel functions J0(red), J1(green), J2(blue)</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselJ_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselJ_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselJ_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the s-th zero of the Bessel J<sub>n</sub> function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselY">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselY" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of
n-th order, Y<sub>n</sub>(x)</p>
<figure class="align-default" id="id8">
<img alt="_images/sf-bessel-Y.png" src="_images/sf-bessel-Y.png" />
<figcaption>
<p><span class="caption-text">Bessel functions Y0(red), Y1(green), Y2(blue)</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselYnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselYnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselYnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular cylindrical Bessel function of fractional order <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(Y_\nu(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselI">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselI_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselI_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselI_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Regular modified cylindrical Bessel function of n-th order and their scaled version.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselInu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselInu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselInu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselInu_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselInu_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselInu_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the (scaled) regular modified Bessel function of fractional order <span class="math notranslate nohighlight">\(\nu\)</span> with <span class="math notranslate nohighlight">\(I_{\nu}(x)\)</span> for x&gt;0, nu&gt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselK">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselK_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselK_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselK_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Irregular modified cylindrical Bessel function of order n and their scaled version.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselKnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselKnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselKnu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.bessellnKnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">bessellnKnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.bessellnKnu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselKnu_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselKnu_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselKnu_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (scaled or logarithm) irregular modified Bessel function of fractional order <span class="math notranslate nohighlight">\(\nu, K_\nu(x)\)</span> for x&gt;0, nu&gt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselj">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselj" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the regular spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.bessely">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">bessely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.bessely" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besseli_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besseli_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besseli_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scaled regular modified spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselk">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular modified spherical Bessel function of l-th order.</p>
</dd></dl>

</section>
<section id="clausen-function">
<h3>Clausen Function<a class="headerlink" href="#clausen-function" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.clausen">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">clausen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.clausen" title="Permalink to this definition">¶</a></dt>
<dd><p>The Clausen function is defined by the following integral,</p>
<div class="math notranslate nohighlight">
\[Cl_2(x) = - \int_0^x dt \log(2 \sin(t/2))\]</div>
<p>It is related to the dilogarithm by <span class="math notranslate nohighlight">\(Cl_2(\theta) = \Im Li_2(\exp(i\theta))\)</span>.</p>
</dd></dl>

</section>
<section id="coulomb-functions">
<h3>Coulomb Functions<a class="headerlink" href="#coulomb-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.hydrogenicR_1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hydrogenicR_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hydrogenicR_1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction</p>
<div class="math notranslate nohighlight">
\[R_1 := 2Z \sqrt{Z} \exp(-Z r)\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hydrogenicR">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hydrogenicR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hydrogenicR" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the n-th normalized hydrogenic bound state radial wave function,</p>
<div class="math notranslate nohighlight">
\[R_n := 2 (Z^{3/2}/n^2) \sqrt{(n-l-1)!/(n+l)!} \exp(-Z r/n) (2Zr/n)^lL^{2l+1}_{n-l-1}(2Zr/n)\]</div>
<p>where <span class="math notranslate nohighlight">\(L^a_b(x)\)</span> is the generalized Laguerre polynomial (see Laguerre Functions).
The normalization is chosen such that the wave function <span class="math notranslate nohighlight">\(\psi\)</span> is given by <span class="math notranslate nohighlight">\(\psi(n,l,r) = R_n Y_{lm}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coulomb_wave_FG">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coulomb_wave_FG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coulomb_wave_FG" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Coulomb wave functions <span class="math notranslate nohighlight">\(F_L(\eta,x)\)</span>, <span class="math notranslate nohighlight">\(G_{L-k}(\eta,x)\)</span>
and their derivatives <span class="math notranslate nohighlight">\(F'_L(\eta,x)\)</span>, <span class="math notranslate nohighlight">\(G'_{L-k}(\eta,x)\)</span> with respect to x.
The parameters are restricted to L, L-k &gt; -1/2, x &gt; 0 and integer k.</p>
<p>Note that L itself is not restricted to being an integer.
The results are returned as:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">,</span> <span class="n">Fp</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">Gp</span><span class="p">,</span> <span class="n">exp_F</span><span class="p">,</span> <span class="n">exp_G</span> <span class="o">=</span> <span class="n">coulomb_wave_FG</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">L_F</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">Fp</span></code> and <code class="docutils literal notranslate"><span class="pre">Gp</span></code> being the derivates. If an overflow occurs, GSL_EOVRFLW is returned as an error and scaling exponents are stored in the return values exp_F, exp_G.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coulomb_CL">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coulomb_CL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coulomb_CL" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Coulomb wave function normalization constant <span class="math notranslate nohighlight">\(C_L(\eta)\)</span> for L &gt; -1.</p>
</dd></dl>

</section>
<section id="coupling-coefficients">
<h3>Coupling Coefficients<a class="headerlink" href="#coupling-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_3j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_3j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_3j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 3-j coefficient,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   m_a &amp; m_b &amp; m_c
\end{pmatrix}\end{split}\]</div>
<p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_6j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_6j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_6j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 6-j coefficient,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   j_d &amp; j_e &amp; j_f
\end{pmatrix}\end{split}\]</div>
<p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_9j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_9j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_je</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ji</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_9j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 9-j coefficient,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   j_d &amp; j_e &amp; j_f \\
   j_g &amp; j_h &amp; j_i
\end{pmatrix}\end{split}\]</div>
<p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

</section>
<section id="dawson-function">
<h3>Dawson Function<a class="headerlink" href="#dawson-function" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.dawson">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">dawson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.dawson" title="Permalink to this definition">¶</a></dt>
<dd><p>The Dawson integral is defined by</p>
<div class="math notranslate nohighlight">
\[\exp(-x^2) \int_0^x dt \exp(t^2)\]</div>
<p>A table of Dawson’s integral can be found in Abramowitz &amp; Stegun, Table 7.5.</p>
</dd></dl>

</section>
<section id="debye-functions">
<h3>Debye Functions<a class="headerlink" href="#debye-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.debye">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">debye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.debye" title="Permalink to this definition">¶</a></dt>
<dd><p>The Debye functions <span class="math notranslate nohighlight">\(D_n(x)\)</span> are defined by the following integral,</p>
<div class="math notranslate nohighlight">
\[D_n(x) = {n \over x^n} \int_0^x dt {t^n \over e^t - 1}\]</div>
<p>For further information see Abramowitz &amp; Stegun, Section 27.1.</p>
</dd></dl>

</section>
<section id="dilogarithms">
<h3>Dilogarithms<a class="headerlink" href="#dilogarithms" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.dilog">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">dilog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.dilog" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the dilogarithm for a real argument. In
Lewin’s notation this is Li<sub>2</sub>(x), the real part of the dilogarithm
of a real x.  It is defined by the integral representation</p>
<div class="math notranslate nohighlight">
\[Li_2(x) = - \Re \int_0^x ds {\log(1-s) \over s}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(Im(Li_2(x)) = 0\)</span> for x &lt;= 1, and <span class="math notranslate nohighlight">\(-|pgr| log(x)\)</span> for x &gt; 1.</p>
<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
<span class="math notranslate nohighlight">\(S(x)= Li_2(1-x)\)</span> as the dilogarithm rather than  <span class="math notranslate nohighlight">\(Li_2(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.cdilog">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">cdilog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.cdilog" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dilogarithm for a complex argument.</p>
</dd></dl>

</section>
<section id="elliptic-integrals">
<h3>Elliptic Integrals<a class="headerlink" href="#elliptic-integrals" title="Permalink to this headline">¶</a></h3>
<p>The Legendre forms of elliptic integrals <span class="math notranslate nohighlight">\(F(\phi,k)\)</span>, <span class="math notranslate nohighlight">\(E(\phi,k)\)</span> and <span class="math notranslate nohighlight">\(\Pi(\phi,k,n)\)</span> are defined by,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}F(\phi,k) = \int_0^\phi dt 1/\sqrt((1 - k^2 \sin^2(t)))\\E(\phi,k) = \int_0^\phi dt   \sqrt((1 - k^2 \sin^2(t)))\\Pi(\phi,k,n) = \int_0^\phi dt 1/((1 + n \sin^2(t))\sqrt(1 - k^2 \sin^2(t)))\end{aligned}\end{align} \]</div>
<p>The complete Legendre forms are denoted by <span class="math notranslate nohighlight">\(K(k) = F(\pi/2, k)\)</span> and <span class="math notranslate nohighlight">\(E(k) = E(\pi/2, k)\)</span>.
The notation used here is based on Carlson, Numerische Mathematik 33 (1979) 1 and differs slightly from that used by Abramowitz &amp; Stegun, where the functions are given in terms of the parameter <span class="math notranslate nohighlight">\(m = k^2\)</span> and n is replaced by -n.</p>
<p>The Carlson symmetric forms of elliptical integrals <span class="math notranslate nohighlight">\(RC(x,y)\)</span>, <span class="math notranslate nohighlight">\(RD(x,y,z)\)</span>, <span class="math notranslate nohighlight">\(RF(x,y,z)\)</span> and <span class="math notranslate nohighlight">\(RJ(x,y,z,p)\)</span> are defined by,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}RC(x,y) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1)\\RD(x,y,z) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2)\\RF(x,y,z) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2)\\RJ(x,y,z,p) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1)\end{aligned}\end{align} \]</div>
<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_D">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_D" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(D(\phi,k)\)</span> which is defined through the Carlson form <span class="math notranslate nohighlight">\(RD(x,y,z)\)</span> by the following relation,</p>
<div class="math notranslate nohighlight">
\[D(\phi,k,n) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).\]</div>
<p>The argument n is not used and will be removed in a future release.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_E">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_E</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lk</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_E" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(E(\phi,k)\)</span> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameter <span class="math notranslate nohighlight">\(m = k^2\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_F">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_F</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_F" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(F(\phi,k)\)</span> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameter <span class="math notranslate nohighlight">\(m = k^2\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_P">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_P" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(\Pi(\phi,k,n)\)</span> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameters <span class="math notranslate nohighlight">\(m = k^2\)</span> and <span class="math notranslate nohighlight">\(\sin^2(\alpha) = k^2\)</span>, with the change of sign <span class="math notranslate nohighlight">\(n \to -n\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RC">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RC" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(RC(x,y)\)</span> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RD">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RD" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(RD(x,y,z)\)</span> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RF">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RF" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(RF(x,y,z)\)</span> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RJ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RJ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <span class="math notranslate nohighlight">\(RJ(x,y,z,p)\)</span> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

</section>
<section id="elliptic-function">
<h3>Elliptic Function<a class="headerlink" href="#elliptic-function" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.elljac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">elljac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.elljac" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jacobian elliptic functions <span class="math notranslate nohighlight">\(sn(u|m)\)</span>, <span class="math notranslate nohighlight">\(cn(u|m)\)</span>, <span class="math notranslate nohighlight">\(dn(u|m)\)</span> by descending Landen transformations.
It returns sn, cn and dn as:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">sn</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">elljac</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="error-functions">
<h3>Error Functions<a class="headerlink" href="#error-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.erf">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>The error function erf(x)</p>
<div class="math notranslate nohighlight">
\[{2 \over \sqrt{\pi}} \int_0^x dt e^{-t^2}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erfc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erfc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_erfc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the (logarithmic) complementary error function <span class="math notranslate nohighlight">\(erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erf_Q">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the upper tail of the Gaussian probability function <span class="math notranslate nohighlight">\(Q(x) = (1/\sqrt{2\pi}) \int_x^\infty dt \exp(-t^2/2\)</span></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erf_Z">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf_Z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf_Z" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gaussian probability density function <span class="math notranslate nohighlight">\(Z(x) = (1/\sqrt{2\pi}) \exp(-x^2/2)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hazard">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hazard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hazard" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the hazard function for the normal distribution.</p>
</dd></dl>

</section>
<section id="exponential-functions">
<h3>Exponential Functions<a class="headerlink" href="#exponential-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.exp">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines provide an exponential function <span class="math notranslate nohighlight">\(\exp(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_err">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_err</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_err" title="Permalink to this definition">¶</a></dt>
<dd><p>This function exponentiates x with an associated absolute error dx.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_mult">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_mult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines exponentiate x and multiply by the factor y to return the product <span class="math notranslate nohighlight">\(y \exp(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_mult_err">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_mult_err</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_mult_err" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine computes the product <span class="math notranslate nohighlight">\(y \exp(x)\)</span> for the quantities x, y with associated absolute errors dx, dy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expm1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <span class="math notranslate nohighlight">\(\exp(x)-1\)</span> using an algorithm that is accurate for small x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <span class="math notranslate nohighlight">\((\exp(x)-1)/x\)</span> using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion <span class="math notranslate nohighlight">\((\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \dots\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel_2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel_2" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <span class="math notranslate nohighlight">\(2(\exp(x)-1-x)/x^2\)</span> using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion <span class="math notranslate nohighlight">\(2(\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \dots\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel_n">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel_n" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the N-relative exponential given by,</p>
<div class="math notranslate nohighlight">
\[exprel_N(x) = N!/x^N (\exp(x) - \sum_{k=0}^{N-1} x^k/k!)
            = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
            = 1F1 (1,1+N,x)\]</div>
</dd></dl>

</section>
<section id="exponential-integrals">
<h3>Exponential Integrals<a class="headerlink" href="#exponential-integrals" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_E">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_E</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_E" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the exponential integral <span class="math notranslate nohighlight">\(E_n(x)\)</span> of order n,</p>
<div class="math notranslate nohighlight">
\[E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_Ei">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_Ei</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_Ei" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the exponential integral <span class="math notranslate nohighlight">\(Ei(x)\)</span>,</p>
<div class="math notranslate nohighlight">
\[Ei(x) := - PV(\int_{-x}^\infty dt \exp(-t)/t)\]</div>
<p>where PV denotes the principal value of the integral.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Shi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Shi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Shi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the integral <span class="math notranslate nohighlight">\(Shi(x) = \int_0^x dt \sinh(t)/t\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Chi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Chi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the integral <span class="math notranslate nohighlight">\(Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]\)</span> , where <span class="math notranslate nohighlight">\(\gamma_E\)</span> is the Euler constant (available as the macro M_EULER).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_3">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_3" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the third-order exponential integral <span class="math notranslate nohighlight">\(Ei_3(x) = \int_0^xdt \exp(-t^3)\)</span> for x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Si">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Si</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Si" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Sine integral <span class="math notranslate nohighlight">\(Si(x) = \int_0^x dt \sin(t)/t\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Ci">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Ci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Ci" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Cosine integral <span class="math notranslate nohighlight">\(Ci(x) = -\int_x^\infty dt \cos(t)/t\)</span> for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.atanint">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">atanint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.atanint" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Arctangent integral, which is defined as <span class="math notranslate nohighlight">\(AtanInt(x) = \int_0^x dt \arctan(t)/t\)</span>.</p>
</dd></dl>

</section>
<section id="fermi-dirac-function">
<h3>Fermi Dirac Function<a class="headerlink" href="#fermi-dirac-function" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.fermi_dirac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fermi_dirac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fermi_dirac" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete Fermi-Dirac integral F<sub>n</sub>(x) is given by,</p>
<div class="math notranslate nohighlight">
\[F_n(x) = {1 \over \Gamma(n+1)} \int_0^\infty dt {t^n \over e^{t-x} + 1}\]</div>
<p>Note that the Fermi-Dirac integral is sometimes defined without the normalization factor in other texts.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.fermi_dirac_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fermi_dirac_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fermi_dirac_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, <span class="math notranslate nohighlight">\(F_0(x,b) = \ln(1 + e^{b-x}) - (b-x)\)</span>.</p>
<p>The incomplete Fermi-Dirac integral <span class="math notranslate nohighlight">\(F_j(x,b)\)</span> is given by,</p>
<div class="math notranslate nohighlight">
\[F_j(x,b)   := (1/\Gamma(j+1)) \int_b^\infty dt (t^j / (\exp(t-x) + 1))\]</div>
</dd></dl>

</section>
<section id="gamma-and-beta-functions">
<h3>Gamma and Beta Functions<a class="headerlink" href="#gamma-and-beta-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Shi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral <span class="math notranslate nohighlight">\(\textrm{Shi}(x) = \int_0^x dt \sinh(t)/t\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral</p>
<div class="math notranslate nohighlight">
\[\textrm{Chi}(x) = \Re \left( \gamma_E +
\log(x) + \int_0^x dt \dfrac{\cosh(t)-1}{t} \right)\]</div>
<p>where γ<sub>E</sub> is the Euler constant.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id3">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Si</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Sine integral <span class="math notranslate nohighlight">\(\textrm{Si}(x) = \int_0^x dt \dfrac{\sin(t)}{t}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id4">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Ci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cosine integral <span class="math notranslate nohighlight">\(\textrm{Ci}(x) = -\int_x^\infty dt \dfrac{\cos(t)}{t}\)</span> for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id5">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">atanint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the Arctangent integral, which is defined as <span class="math notranslate nohighlight">\(\textrm{AtanInt}(x) = \int_0^x dt \dfrac{\arctan(t)}{t}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.fact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the factorial n!. The factorial is related to the Gamma function by <span class="math notranslate nohighlight">\(n! = |Ggr| (n+1)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.doublefact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">doublefact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.doublefact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the double factorial <span class="math notranslate nohighlight">\(n!! = n(n-2)(n-4) \dots\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnfact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnfact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnfact" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the factorial of N, log(n!). The algorithm is faster than computing ln(Γ (n+1)).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lndoublefact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lndoublefact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lndoublefact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of the double factorial of N, log(n!!).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.choose">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">choose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the combinatorial factor</p>
<div class="math notranslate nohighlight">
\[\binom{n}{k} = \dfrac{n!}{k! (n-k)!}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnchoose">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnchoose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnchoose" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of “n choose m”.  This is equivalent to the sum <span class="math notranslate nohighlight">\(\log(n!) - \log(m!) - \log((n-m)!)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Gamma function Γ (x), subject to x not being a negative integer or zero.  The function is computed using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lngamma">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lngamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lngamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of the Gamma function, <span class="math notranslate nohighlight">\(\log(\Gamma(x))\)</span>, subject to x not being a negative integer or zero.  For x&lt;0 the real part of <span class="math notranslate nohighlight">\(\log(\Gamma(x))\)</span> is returned, which  is equivalent to <span class="math notranslate nohighlight">\(\log(|\Gamma(x)|)\)</span>. The function is computed using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gammastar">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gammastar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gammastar" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regulated Gamma Function <span class="math notranslate nohighlight">\(\Gamma^*(x)\)</span> for x &gt; 0. The regulated gamma function is given by,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Gamma^*(x) = \Gamma(x)/(\sqrt{2\pi} x^{(x-1/2)} \exp(-x))\\            = (1 + (1/12x) + ...)  for x \to \infty\end{aligned}\end{align} \]</div>
<p>and is a useful suggestion of Temme.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gammainv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gammainv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gammainv" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the reciprocal of the gamma function, <span class="math notranslate nohighlight">\(1/\Gamma(x)\)</span> using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lngammac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lngammac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lngammac" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine computes <span class="math notranslate nohighlight">\(\log(\Gamma(z))\)</span> for complex z and z not a negative integer or zero, using the complex Lanczos method.
The returned parameters are <span class="math notranslate nohighlight">\(lnr = \log|\Gamma(z)|\)</span> and <span class="math notranslate nohighlight">\(arg = \arg(\Gamma(z)) in (-\pi,\pi]\)</span>.
Note that the phase part (arg) is not well-determined when <span class="math notranslate nohighlight">\(|z|\)</span> is very large, due to inevitable roundoff in restricting to (-pi,pi]. This will result in a GSL_ELOSS error when it occurs. The absolute value part (lnr), however, never suffers from loss of precision.</p>
<p>The functions returns:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">lnr</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">lngammac</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.beta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Beta Function, <span class="math notranslate nohighlight">\(B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b)\)</span> subject to a and b not being negative integers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnbeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnbeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnbeta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the Beta Function, <span class="math notranslate nohighlight">\(\log(B(a,b))\)</span> subject to a and b not being negative integers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.beta_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">beta_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.beta_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized incomplete Beta function <span class="math notranslate nohighlight">\(I_x(a,b)=B_x(a,b)/B(a,b)\)</span> where <span class="math notranslate nohighlight">\(B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt\)</span> for 0 &lt;= x &lt;= 1.
For a &gt; 0, b &gt; 0 the value is computed using a continued fraction expansion. For all other values it is computed using the relation <span class="math notranslate nohighlight">\(I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.taylorcoeff">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">taylorcoeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.taylorcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Taylor coefficient <span class="math notranslate nohighlight">\(x^n / n!\)</span> for x &gt;= 0, n &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.poch">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">poch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.poch" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Pochhammer symbol <span class="math notranslate nohighlight">\((a)_x = \Gamma(a + x)/\Gamma(a)\)</span>. The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x). When a and a+x are negative integers or zero, the limiting value of the ratio is returned.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnpoch">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnpoch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnpoch" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the Pochhammer symbol, <span class="math notranslate nohighlight">\(\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a))\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.pochrel">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">pochrel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.pochrel" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the relative Pochhammer symbol <span class="math notranslate nohighlight">\(((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions compute the unnormalized incomplete Gamma Function <span class="math notranslate nohighlight">\(\Gamma(a,x) = \int_x^\infty dt t^{a-1} \exp(-t)\)</span> for a real and x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc_Q">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized incomplete Gamma Function <span class="math notranslate nohighlight">\(Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^{a-1} \exp(-t)\)</span> for a &gt; 0, x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc_P">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc_P" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the complementary normalized incomplete Gamma Function <span class="math notranslate nohighlight">\(P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^{a-1} \exp(-t)\)</span>
for a &gt; 0, x &gt;= 0. Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma function (section 6.5).</p>
</dd></dl>

</section>
<section id="gegenbauer-functions">
<h3>Gegenbauer Functions<a class="headerlink" href="#gegenbauer-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.gegenpoly">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gegenpoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gegenpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions evaluate the Gegenbauer polynomial <span class="math notranslate nohighlight">\(C^{(\lambda)}_n(x)\)</span>
for a specific value of n, lambda, x subject to <span class="math notranslate nohighlight">\(\lambda &gt; -1/2\)</span>, n &gt;= 0.</p>
</dd></dl>

</section>
<section id="hypergeometric-functions">
<h3>Hypergeometric functions<a class="headerlink" href="#hypergeometric-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg0F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg0F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg0F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the hypergeometric function <span class="math notranslate nohighlight">\(0F1(c,x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg1F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg1F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg1F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the confluent hypergeometric function <span class="math notranslate nohighlight">\(1F1(m,n,x) = M(m,n,x)\)</span>. The parameters m and n can be integer or real numbers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hypergU">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hypergU</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hypergU" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the confluent hypergeometric function <span class="math notranslate nohighlight">\(U(m,n,x)\)</span>. The parameters m and n can be integer or real numbers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg2F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg2F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg2F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gauss hypergeometric function <span class="math notranslate nohighlight">\(2F1(a,b,c,x) = F(a,b,c,x)\)</span> for <span class="math notranslate nohighlight">\(|x| &lt; 1\)</span>.</p>
<p>If the arguments (a,b,c,x) are too close to a singularity then the function can return the error code <code class="docutils literal notranslate"><span class="pre">GSL_EMAXITER</span></code> when the series approximation converges too slowly.
This occurs in the region of x=1, c - a - b = m for integer m.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg2F1conj">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg2F1conj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg2F1conj" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gauss hypergeometric function <span class="math notranslate nohighlight">\(2F1(a, a^*, c, x)\)</span> where a is complex parameter, c and x are real parameters with <span class="math notranslate nohighlight">\(|x| &lt; 1\)</span>.</p>
</dd></dl>

</section>
<section id="laguerre-functions">
<h3>Laguerre Functions<a class="headerlink" href="#laguerre-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.laguerre">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">laguerre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.laguerre" title="Permalink to this definition">¶</a></dt>
<dd><p>The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as</p>
<div class="math notranslate nohighlight">
\[L^a_n(x) = {(a+1)_n \over n!} {}_1 F_1(-n,a+1,x)\]</div>
<p>and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials <span class="math notranslate nohighlight">\(L_n(x)\)</span> by</p>
<div class="math notranslate nohighlight">
\[L^0_n(x) = L_n(x)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[L^k_n(x) = (-1)^k {d^k \over dx^k} L_{n+k}(x)\]</div>
<p>For more information see Abramowitz &amp; Stegun, Chapter 22.</p>
</dd></dl>

</section>
<section id="lambert-w-functions">
<h3>Lambert W Functions<a class="headerlink" href="#lambert-w-functions" title="Permalink to this headline">¶</a></h3>
<p>Lambert’s W functions, W(x), are defined to be solutions of the equation <span class="math notranslate nohighlight">\(W(x) \exp(W(x)) = x\)</span>.
This function has multiple branches for x &lt; 0; however, it has only two real-valued branches.
We define <span class="math notranslate nohighlight">\(W_0(x)\)</span> to be the principal branch, where W &gt; -1 for x &lt; 0, and <span class="math notranslate nohighlight">\(W_{-1}(x)\)</span> to be the other real branch, where W &lt; -1 for x &lt; 0.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.lambertW0">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lambertW0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lambertW0" title="Permalink to this definition">¶</a></dt>
<dd><p>These compute the principal branch of the Lambert W function, <span class="math notranslate nohighlight">\(W_0(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lambertWm1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lambertWm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lambertWm1" title="Permalink to this definition">¶</a></dt>
<dd><p>These compute the secondary real-valued branch of the Lambert W function, <span class="math notranslate nohighlight">\(W_{-1}(x)\)</span>.</p>
</dd></dl>

</section>
<section id="legendre-functions-and-spherical-harmonics">
<h3>Legendre Functions and Spherical Harmonics<a class="headerlink" href="#legendre-functions-and-spherical-harmonics" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.legendreP">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendreP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendreP" title="Permalink to this definition">¶</a></dt>
<dd><figure class="align-default" id="id9">
<img alt="_images/examples-legendre-polynomials.png" src="_images/examples-legendre-polynomials.png" />
<figcaption>
<p><span class="caption-text">Legendre polynomials</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>These functions evaluate the Legendre polynomial <span class="math notranslate nohighlight">\(P_l(x)\)</span> for a specific value of l, x subject to l &gt;= 0, <span class="math notranslate nohighlight">\(|x| &lt;= 1\)</span></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendreQ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendreQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendreQ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Legendre function <span class="math notranslate nohighlight">\(Q_l(x)\)</span> for x &gt; -1, x != 1 and l &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendrePlm">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendrePlm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendrePlm" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the associated Legendre polynomial <span class="math notranslate nohighlight">\(P_l^m(x)\)</span> for m &gt;= 0, l &gt;= m, <span class="math notranslate nohighlight">\(|x| &lt;= 1\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendresphPlm">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendresphPlm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendresphPlm" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized associated Legendre polynomial <span class="math notranslate nohighlight">\(\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)!/(l+m)!} P_l^m(x)\)</span> suitable for use in spherical harmonics. The parameters must satisfy m &gt;= 0, l &gt;= m, <span class="math notranslate nohighlight">\(|x| &lt;= 1\)</span>. Theses routines avoid the overflows that occur for the standard normalization of <span class="math notranslate nohighlight">\(P_l^m(x)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalP">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalP" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regular Spherical Conical Function <span class="math notranslate nohighlight">\(P^{n}_{-1/2 + i \lambda}(x)\)</span> for x &gt; -1 where n in {-12, 0, 12, 1}</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalPsphreg">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalPsphreg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalPsphreg" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Regular Spherical Conical Function <span class="math notranslate nohighlight">\(P^{-1/2-l}_{-1/2 + i \lambda}(x)\)</span> for x &gt; -1, l &gt;= -1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalPcylreg">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalPcylreg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalPcylreg" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Regular Cylindrical Conical Function <span class="math notranslate nohighlight">\(P^{-m}_{-1/2 + i \lambda}(x)\)</span> for x &gt; -1, m &gt;= -1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendre_H3d">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendre_H3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendre_H3d" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space <span class="math notranslate nohighlight">\(\eta &gt;= 0\)</span>, l &gt;= 0. In the flat limit this takes the form <span class="math notranslate nohighlight">\(L^{H3d}_l(\lambda,\eta) = j_l(\lambda\eta)\)</span>.</p>
</dd></dl>

</section>
<section id="logarithm-and-related-functions">
<h3>Logarithm and Related Functions<a class="headerlink" href="#logarithm-and-related-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.log">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of x, <span class="math notranslate nohighlight">\(\log(x)\)</span>, for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_abs">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the magnitude of x, <span class="math notranslate nohighlight">\(\log(|x|)\)</span>, for x ne 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_1plusx">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_1plusx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_1plusx" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute <span class="math notranslate nohighlight">\(\log(1 + x)\)</span> for x &gt; -1 using an algorithm that is accurate for small x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_1plusx_mx">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_1plusx_mx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_1plusx_mx" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute <span class="math notranslate nohighlight">\(\log(1 + x) - x\)</span> for x &gt; -1 using an algorithm that is accurate for small x.</p>
</dd></dl>

</section>
<section id="psi-digamma-functions">
<h3>Psi (Digamma) Functions<a class="headerlink" href="#psi-digamma-functions" title="Permalink to this headline">¶</a></h3>
<p>The polygamma functions of order n are defined by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\psi^{(n)}(x) = (d/dx)^n \psi(x) = (d/dx)^{n+1} \log(\Gamma(x))\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\psi(x) = \Gamma'(x)/\Gamma(x)\)</span> is known as the digamma function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.psi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the digamma function <span class="math notranslate nohighlight">\(\psi(x)\)</span> for general x, x ne 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.psi_1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi_1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Trigamma function <span class="math notranslate nohighlight">\(\psi'(x)\)</span> for general x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.1piy">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">1piy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.1piy" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the real part of the digamma function on the line 1+i y, <span class="math notranslate nohighlight">\(\Re[\psi(1 + i y)]\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.psi_n">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi_n" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the polygamma function <span class="math notranslate nohighlight">\(\psi^{(n)}(x)\)</span> for n &gt;= 0, x &gt; 0.</p>
</dd></dl>

</section>
<section id="synchrotron-functions">
<h3>Synchrotron Functions<a class="headerlink" href="#synchrotron-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.synchrotron1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">synchrotron1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.synchrotron1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the first synchrotron function <span class="math notranslate nohighlight">\(x \int_x^\infty dt K_{5/3}(t)\)</span> for x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.synchrotron2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">synchrotron2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.synchrotron2" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the second synchrotron function <span class="math notranslate nohighlight">\(x K_{2/3}(x)\)</span> for x &gt;= 0.</p>
</dd></dl>

</section>
<section id="transport-functions">
<h3>Transport Functions<a class="headerlink" href="#transport-functions" title="Permalink to this headline">¶</a></h3>
<p>The transport functions J(n,x) are defined by the integral representations <span class="math notranslate nohighlight">\(J(n,x) := \int_0^x dt t^n e^t /(e^t - 1)^2\)</span>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.transport">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the transport function <span class="math notranslate nohighlight">\(J(n,x)\)</span> with <span class="math notranslate nohighlight">\(n \in {2,3,4,5}\)</span></p>
</dd></dl>

</section>
<section id="zeta-functions">
<h3>Zeta Functions<a class="headerlink" href="#zeta-functions" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.zeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>The Riemann zeta function is defined by the infinite sum <span class="math notranslate nohighlight">\(\zeta(s) = \sum_{k=1}^\infty k^{-s}\)</span>.
These routines compute the Riemann zeta function <span class="math notranslate nohighlight">\(\zeta(s)\)</span> for arbitrary s, <span class="math notranslate nohighlight">\(s \ne 1\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.zetam1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">zetam1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.zetam1" title="Permalink to this definition">¶</a></dt>
<dd><p>For large positive argument, the Riemann zeta function approaches one. In this region the fractional part is interesting, and therefore we need a function to evaluate it explicitly.
These routines compute <span class="math notranslate nohighlight">\(\zeta(s) - 1\)</span> for arbitrary s, <span class="math notranslate nohighlight">\(s \ne 1\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.eta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">eta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>The eta function is defined by <span class="math notranslate nohighlight">\(\eta(s) = (1-2^{1-s}) \zeta(s)\)</span>.
These routines compute the eta function eta(s) for arbitrary s.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hzeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hzeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Hurwitz zeta function <span class="math notranslate nohighlight">\(\zeta(s,q)\)</span> for s &gt; 1, q &gt; 0.</p>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Special functions</a><ul>
<li><a class="reference internal" href="#module-sf">Overview</a><ul>
<li><a class="reference internal" href="#airy-functions">Airy Functions</a></li>
<li><a class="reference internal" href="#bessel-functions">Bessel Functions</a></li>
<li><a class="reference internal" href="#clausen-function">Clausen Function</a></li>
<li><a class="reference internal" href="#coulomb-functions">Coulomb Functions</a></li>
<li><a class="reference internal" href="#coupling-coefficients">Coupling Coefficients</a></li>
<li><a class="reference internal" href="#dawson-function">Dawson Function</a></li>
<li><a class="reference internal" href="#debye-functions">Debye Functions</a></li>
<li><a class="reference internal" href="#dilogarithms">Dilogarithms</a></li>
<li><a class="reference internal" href="#elliptic-integrals">Elliptic Integrals</a></li>
<li><a class="reference internal" href="#elliptic-function">Elliptic Function</a></li>
<li><a class="reference internal" href="#error-functions">Error Functions</a></li>
<li><a class="reference internal" href="#exponential-functions">Exponential Functions</a></li>
<li><a class="reference internal" href="#exponential-integrals">Exponential Integrals</a></li>
<li><a class="reference internal" href="#fermi-dirac-function">Fermi Dirac Function</a></li>
<li><a class="reference internal" href="#gamma-and-beta-functions">Gamma and Beta Functions</a></li>
<li><a class="reference internal" href="#gegenbauer-functions">Gegenbauer Functions</a></li>
<li><a class="reference internal" href="#hypergeometric-functions">Hypergeometric functions</a></li>
<li><a class="reference internal" href="#laguerre-functions">Laguerre Functions</a></li>
<li><a class="reference internal" href="#lambert-w-functions">Lambert W Functions</a></li>
<li><a class="reference internal" href="#legendre-functions-and-spherical-harmonics">Legendre Functions and Spherical Harmonics</a></li>
<li><a class="reference internal" href="#logarithm-and-related-functions">Logarithm and Related Functions</a></li>
<li><a class="reference internal" href="#psi-digamma-functions">Psi (Digamma) Functions</a></li>
<li><a class="reference internal" href="#synchrotron-functions">Synchrotron Functions</a></li>
<li><a class="reference internal" href="#transport-functions">Transport Functions</a></li>
<li><a class="reference internal" href="#zeta-functions">Zeta Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="integ.html"
                          title="previous chapter">Numerical Integration</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="vegas.html"
                          title="next chapter">Monte Carlo Integration</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/sf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vegas.html" title="Monte Carlo Integration"
             >next</a> |</li>
        <li class="right" >
          <a href="integ.html" title="Numerical Integration"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GSL Shell 2.3.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Special functions</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2013, Francesco Abbate.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>