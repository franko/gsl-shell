
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Special functions &#8212; GSL Shell 2.3.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Monte Carlo Integration" href="vegas.html" />
    <link rel="prev" title="Numerical Integration" href="integ.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vegas.html" title="Monte Carlo Integration"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="integ.html" title="Numerical Integration"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GSL Shell 2.3.6 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Special functions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="special-functions">
<span id="id1"></span><h1>Special functions<a class="headerlink" href="#special-functions" title="Permalink to this heading">¶</a></h1>
<p>The library includes routines for calculating the values of Airy functions, Bessel functions, Clausen functions, Coulomb wave functions, Coupling coefficients, the Dawson function, Debye functions, Dilogarithms, Elliptic integrals, Jacobi elliptic functions, Error functions, Exponential integrals, Fermi-Dirac functions, Gamma functions, Gegenbauer functions, Hypergeometric functions, Laguerre functions, Legendre functions and Spherical Harmonics, the Psi (Digamma) Function, Synchrotron functions, Transport functions, Trigonometric functions and Zeta functions.
Any error returned by the special function (such as invalid input domains, etc…) will be signaled.</p>
<section id="module-sf">
<span id="overview"></span><h2>Overview<a class="headerlink" href="#module-sf" title="Permalink to this heading">¶</a></h2>
<section id="airy-functions">
<h3>Airy Functions<a class="headerlink" href="#airy-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi" title="Permalink to this definition">¶</a></dt>
<dd><p>The Airy functions <img class="math" src="_images/math/f1472dc18449835042fd23c0f9e25bb8ee921152.png" alt="Ai(x)"/> and <img class="math" src="_images/math/a252e9cff72ce562bcc96cc821be8d04e4eac74a.png" alt="Bi(x)"/> are defined by the integral representations,</p>
<div class="math">
<p><img src="_images/math/1b52eefd22c6920dc993edaf585e354ac27f60f6.png" alt="Ai(x) = {1 \over \pi} \int_0^\infty \cos({1 \over 3} t^3 + xt) dt

Bi(x) = {1 \over \pi} \int_0^\infty \left( e^{-{1 \over 3} t^3} + \sin(1/3 \, t^3 + xt) \right) dt"/></p>
</div><p>For further information see Abramowitz &amp; Stegun, Section 10.4.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_scaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute a scaled version of the Airy function <img class="math" src="_images/math/fb2cccd2f9e2e69ca67f1a2bfea96bcce52e87e2.png" alt="S_A(x) Ai(x)"/>.
For x&gt;0 the scaling factor <img class="math" src="_images/math/593f940f926895264a1be2240bbd8cc9709c9837.png" alt="S_A(x)"/> is</p>
<div class="math">
<p><img src="_images/math/513921d32d5764c4b10f96630f4f028bd5fa34c4.png" alt="\exp(+(2/3) x^(3/2))"/></p>
</div><p>and is 1 for x&lt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv_scaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Airy function derivatives and their scaled version with the same scaling factor as the airyAi_scaled and airyBi_scaled versions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyAi_deriv_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyAi_deriv_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyAi_deriv_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.airyBi_deriv_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">airyBi_deriv_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.airyBi_deriv_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the n-th zero of the respective functions or their derivatives.</p>
<figure class="align-default" id="id6">
<img alt="_images/examples-airy-functions-plot.png" src="_images/examples-airy-functions-plot.png" />
<figcaption>
<p><span class="caption-text">Airy functions Ai and Bi.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

</section>
<section id="bessel-functions">
<h3>Bessel Functions<a class="headerlink" href="#bessel-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.besselJ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselJ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of
n-th order, J<sub>n</sub>(x)</p>
<figure class="align-default" id="id7">
<img alt="_images/sf-besselJ-functions.png" src="_images/sf-besselJ-functions.png" />
<figcaption>
<p><span class="caption-text">Bessel functions J0(red), J1(green), J2(blue)</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselJ_zero">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselJ_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselJ_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the s-th zero of the Bessel J<sub>n</sub> function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselY">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselY" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of
n-th order, Y<sub>n</sub>(x)</p>
<figure class="align-default" id="id8">
<img alt="_images/sf-bessel-Y.png" src="_images/sf-bessel-Y.png" />
<figcaption>
<p><span class="caption-text">Bessel functions Y0(red), Y1(green), Y2(blue)</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselYnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselYnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselYnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular cylindrical Bessel function of fractional order <img class="math" src="_images/math/14eb89266154200b9c81dcfc3bd058638fa221bf.png" alt="\nu"/>, <img class="math" src="_images/math/0adacac2ec639f6755d9ee5b7dc8addd5647b580.png" alt="Y_\nu(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselI">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselI_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselI_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselI_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Regular modified cylindrical Bessel function of n-th order and their scaled version.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselInu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselInu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselInu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselInu_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselInu_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselInu_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the (scaled) regular modified Bessel function of fractional order <img class="math" src="_images/math/14eb89266154200b9c81dcfc3bd058638fa221bf.png" alt="\nu"/> with <img class="math" src="_images/math/18e4b9f4bf6304ebbd1a507b84e86984b84d9ec7.png" alt="I_{\nu}(x)"/> for x&gt;0, nu&gt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselK">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselK_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselK_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselK_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Irregular modified cylindrical Bessel function of order n and their scaled version.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselKnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselKnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselKnu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.bessellnKnu">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">bessellnKnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.bessellnKnu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselKnu_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselKnu_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselKnu_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (scaled or logarithm) irregular modified Bessel function of fractional order <img class="math" src="_images/math/85fc70f083b91c23dc5a20cfced16e8091b7d4da.png" alt="\nu, K_\nu(x)"/> for x&gt;0, nu&gt;0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselj">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselj" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the regular spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.bessely">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">bessely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.bessely" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besseli_scaled">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besseli_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besseli_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scaled regular modified spherical Bessel function of l-th order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.besselk">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">besselk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the irregular modified spherical Bessel function of l-th order.</p>
</dd></dl>

</section>
<section id="clausen-function">
<h3>Clausen Function<a class="headerlink" href="#clausen-function" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.clausen">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">clausen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.clausen" title="Permalink to this definition">¶</a></dt>
<dd><p>The Clausen function is defined by the following integral,</p>
<div class="math">
<p><img src="_images/math/d101c4b731b0241665cb1314ab6f2cb3e1e32d7c.png" alt="Cl_2(x) = - \int_0^x dt \log(2 \sin(t/2))"/></p>
</div><p>It is related to the dilogarithm by <img class="math" src="_images/math/5de85398f098fa0ac7dbec8614c313aa4494315b.png" alt="Cl_2(\theta) = \Im Li_2(\exp(i\theta))"/>.</p>
</dd></dl>

</section>
<section id="coulomb-functions">
<h3>Coulomb Functions<a class="headerlink" href="#coulomb-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.hydrogenicR_1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hydrogenicR_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hydrogenicR_1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction</p>
<div class="math">
<p><img src="_images/math/cb5a0244b63f6cef94fe9e2b6a787cbb3742406b.png" alt="R_1 := 2Z \sqrt{Z} \exp(-Z r)"/></p>
</div></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hydrogenicR">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hydrogenicR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hydrogenicR" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the n-th normalized hydrogenic bound state radial wave function,</p>
<div class="math">
<p><img src="_images/math/0112503bdbbd96076128c632394b2427a6763c12.png" alt="R_n := 2 (Z^{3/2}/n^2) \sqrt{(n-l-1)!/(n+l)!} \exp(-Z r/n) (2Zr/n)^lL^{2l+1}_{n-l-1}(2Zr/n)"/></p>
</div><p>where <img class="math" src="_images/math/2248838a3601ce71c743b9d2832b7fb360868227.png" alt="L^a_b(x)"/> is the generalized Laguerre polynomial (see Laguerre Functions).
The normalization is chosen such that the wave function <img class="math" src="_images/math/b6c245d487949782a89cab9ee83504a62fdc2337.png" alt="\psi"/> is given by <img class="math" src="_images/math/e99bb72e662a55a117919173a2b654c0752115e7.png" alt="\psi(n,l,r) = R_n Y_{lm}"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coulomb_wave_FG">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coulomb_wave_FG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coulomb_wave_FG" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Coulomb wave functions <img class="math" src="_images/math/eef91b275214e622c229ef544a7c66dec52d8353.png" alt="F_L(\eta,x)"/>, <img class="math" src="_images/math/2021db8ccb6faae0e8bb4b358d4f48d7fe1c4d11.png" alt="G_{L-k}(\eta,x)"/>
and their derivatives <img class="math" src="_images/math/7ad52da13fd49d831e276ae43ef8640c0f30654f.png" alt="F'_L(\eta,x)"/>, <img class="math" src="_images/math/f6f64ce5ede6292536151228ee5f1fb14376c7de.png" alt="G'_{L-k}(\eta,x)"/> with respect to x.
The parameters are restricted to L, L-k &gt; -1/2, x &gt; 0 and integer k.</p>
<p>Note that L itself is not restricted to being an integer.
The results are returned as:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">,</span> <span class="n">Fp</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">Gp</span><span class="p">,</span> <span class="n">exp_F</span><span class="p">,</span> <span class="n">exp_G</span> <span class="o">=</span> <span class="n">coulomb_wave_FG</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">L_F</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">Fp</span></code> and <code class="docutils literal notranslate"><span class="pre">Gp</span></code> being the derivates. If an overflow occurs, GSL_EOVRFLW is returned as an error and scaling exponents are stored in the return values exp_F, exp_G.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coulomb_CL">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coulomb_CL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coulomb_CL" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Coulomb wave function normalization constant <img class="math" src="_images/math/0b76492aefb7a28ad9700581658acf46c8261aed.png" alt="C_L(\eta)"/> for L &gt; -1.</p>
</dd></dl>

</section>
<section id="coupling-coefficients">
<h3>Coupling Coefficients<a class="headerlink" href="#coupling-coefficients" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_3j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_3j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_3j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 3-j coefficient,</p>
<div class="math">
<p><img src="_images/math/1f581a36f1b60d625c079c7d71e733c59b504b12.png" alt="\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   m_a &amp; m_b &amp; m_c
\end{pmatrix}"/></p>
</div><p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_6j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_6j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_mc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_6j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 6-j coefficient,</p>
<div class="math">
<p><img src="_images/math/fed3c7851ac3145dda27e267ce5a5d5b723c6b51.png" alt="\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   j_d &amp; j_e &amp; j_f
\end{pmatrix}"/></p>
</div><p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.coupling_9j">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">coupling_9j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_ja</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_je</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_jh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_ji</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.coupling_9j" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Wigner 9-j coefficient,</p>
<div class="math">
<p><img src="_images/math/fc3226cc8abc5b1499525086fa80fabcd45af149.png" alt="\begin{pmatrix}
   j_a &amp; j_b &amp; j_c \\
   j_d &amp; j_e &amp; j_f \\
   j_g &amp; j_h &amp; j_i
\end{pmatrix}"/></p>
</div><p>where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.</p>
</dd></dl>

</section>
<section id="dawson-function">
<h3>Dawson Function<a class="headerlink" href="#dawson-function" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.dawson">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">dawson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.dawson" title="Permalink to this definition">¶</a></dt>
<dd><p>The Dawson integral is defined by</p>
<div class="math">
<p><img src="_images/math/5f481276e1baffd12872d372e0b19db8c892b53a.png" alt="\exp(-x^2) \int_0^x dt \exp(t^2)"/></p>
</div><p>A table of Dawson’s integral can be found in Abramowitz &amp; Stegun, Table 7.5.</p>
</dd></dl>

</section>
<section id="debye-functions">
<h3>Debye Functions<a class="headerlink" href="#debye-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.debye">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">debye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.debye" title="Permalink to this definition">¶</a></dt>
<dd><p>The Debye functions <img class="math" src="_images/math/1787a7a4957ec9b840e590b5bf3cb23da1690816.png" alt="D_n(x)"/> are defined by the following integral,</p>
<div class="math">
<p><img src="_images/math/031731570ef1b4814d9d4cf36d47862baa809812.png" alt="D_n(x) = {n \over x^n} \int_0^x dt {t^n \over e^t - 1}"/></p>
</div><p>For further information see Abramowitz &amp; Stegun, Section 27.1.</p>
</dd></dl>

</section>
<section id="dilogarithms">
<h3>Dilogarithms<a class="headerlink" href="#dilogarithms" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.dilog">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">dilog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.dilog" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the dilogarithm for a real argument. In
Lewin’s notation this is Li<sub>2</sub>(x), the real part of the dilogarithm
of a real x.  It is defined by the integral representation</p>
<div class="math">
<p><img src="_images/math/f568dc256accff013e6b71adb12373ab3d1d8e7d.png" alt="Li_2(x) = - \Re \int_0^x ds {\log(1-s) \over s}"/></p>
</div><p>Note that <img class="math" src="_images/math/a708ba02ff53bfbc4a328f7c305e21a438720b00.png" alt="Im(Li_2(x)) = 0"/> for x &lt;= 1, and <img class="math" src="_images/math/fc95a06a62326b296d224b76038545d600796b08.png" alt="-|pgr| log(x)"/> for x &gt; 1.</p>
<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
<img class="math" src="_images/math/7584eab86e6d467dee8d1f11c529bea16ab09209.png" alt="S(x)= Li_2(1-x)"/> as the dilogarithm rather than  <img class="math" src="_images/math/830f4417b190daaf669a0281f4548bcc75eeba6d.png" alt="Li_2(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.cdilog">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">cdilog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.cdilog" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dilogarithm for a complex argument.</p>
</dd></dl>

</section>
<section id="elliptic-integrals">
<h3>Elliptic Integrals<a class="headerlink" href="#elliptic-integrals" title="Permalink to this heading">¶</a></h3>
<p>The Legendre forms of elliptic integrals <img class="math" src="_images/math/a6eb14e3bfef9a0e5147fbf4d36dc7f677bf1c2c.png" alt="F(\phi,k)"/>, <img class="math" src="_images/math/b4da54af3162c4ced7b48070d2637a72abaf5c32.png" alt="E(\phi,k)"/> and <img class="math" src="_images/math/af09ff23d3948d68440310fd3834535062565e13.png" alt="\Pi(\phi,k,n)"/> are defined by,</p>
<div class="math">
<p><img src="_images/math/59e3deb17b4408944fbb3a7ab641dc83d9f4d735.png" alt="F(\phi,k) = \int_0^\phi dt 1/\sqrt((1 - k^2 \sin^2(t)))

E(\phi,k) = \int_0^\phi dt   \sqrt((1 - k^2 \sin^2(t)))

Pi(\phi,k,n) = \int_0^\phi dt 1/((1 + n \sin^2(t))\sqrt(1 - k^2 \sin^2(t)))"/></p>
</div><p>The complete Legendre forms are denoted by <img class="math" src="_images/math/7c8aa3bd9dc033e1d27a979576043dfa44711865.png" alt="K(k) = F(\pi/2, k)"/> and <img class="math" src="_images/math/2eb94763ec9952b443a8beff02f7fd55ecf80c2e.png" alt="E(k) = E(\pi/2, k)"/>.
The notation used here is based on Carlson, Numerische Mathematik 33 (1979) 1 and differs slightly from that used by Abramowitz &amp; Stegun, where the functions are given in terms of the parameter <img class="math" src="_images/math/c4a6364b38d934c9ce244a840ba4e63db6ead164.png" alt="m = k^2"/> and n is replaced by -n.</p>
<p>The Carlson symmetric forms of elliptical integrals <img class="math" src="_images/math/13a8419192c5ba9619284f14db7f061dc5a1b3ee.png" alt="RC(x,y)"/>, <img class="math" src="_images/math/d8f6800fa0399f613d68469d472a5f07da46d0f3.png" alt="RD(x,y,z)"/>, <img class="math" src="_images/math/63a3e13d4c8a8d52f9d8986d04bb474f80176e4a.png" alt="RF(x,y,z)"/> and <img class="math" src="_images/math/a8decbf0a704c1ec260cc4758d2d15415712232c.png" alt="RJ(x,y,z,p)"/> are defined by,</p>
<div class="math">
<p><img src="_images/math/7ecfb95f2d832798fd9f1100f78b1924f01fe9b2.png" alt="RC(x,y) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1)

RD(x,y,z) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2)

RF(x,y,z) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2)

RJ(x,y,z,p) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1)"/></p>
</div><dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_D">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_D" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions compute the incomplete elliptic integral <img class="math" src="_images/math/9927a18ef5670dffa592988c03de13e786fc345d.png" alt="D(\phi,k)"/> which is defined through the Carlson form <img class="math" src="_images/math/d8f6800fa0399f613d68469d472a5f07da46d0f3.png" alt="RD(x,y,z)"/> by the following relation,</p>
<div class="math">
<p><img src="_images/math/4001e336ce04ea267fe658df6b333eb803c0c75d.png" alt="D(\phi,k,n) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1)."/></p>
</div><p>The argument n is not used and will be removed in a future release.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_E">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_E</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lk</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_E" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/b4da54af3162c4ced7b48070d2637a72abaf5c32.png" alt="E(\phi,k)"/> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameter <img class="math" src="_images/math/c4a6364b38d934c9ce244a840ba4e63db6ead164.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_F">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_F</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_F" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/a6eb14e3bfef9a0e5147fbf4d36dc7f677bf1c2c.png" alt="F(\phi,k)"/> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameter <img class="math" src="_images/math/c4a6364b38d934c9ce244a840ba4e63db6ead164.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_P">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_P" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/af09ff23d3948d68440310fd3834535062565e13.png" alt="\Pi(\phi,k,n)"/> to the accuracy specified by the mode variable mode. Note that Abramowitz &amp; Stegun define this function in terms of the parameters <img class="math" src="_images/math/c4a6364b38d934c9ce244a840ba4e63db6ead164.png" alt="m = k^2"/> and <img class="math" src="_images/math/3f115c31f4de21a77e97d8c698a3c417c267eef2.png" alt="\sin^2(\alpha) = k^2"/>, with the change of sign <img class="math" src="_images/math/4c8c59237ba55aa6c84d82a9f9892da6607cae86.png" alt="n \to -n"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RC">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RC" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/13a8419192c5ba9619284f14db7f061dc5a1b3ee.png" alt="RC(x,y)"/> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RD">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RD" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/d8f6800fa0399f613d68469d472a5f07da46d0f3.png" alt="RD(x,y,z)"/> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RF">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RF" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/63a3e13d4c8a8d52f9d8986d04bb474f80176e4a.png" alt="RF(x,y,z)"/> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.ellint_RJ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">ellint_RJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.ellint_RJ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/a8decbf0a704c1ec260cc4758d2d15415712232c.png" alt="RJ(x,y,z,p)"/> to the accuracy specified by the mode variable mode.</p>
</dd></dl>

</section>
<section id="elliptic-function">
<h3>Elliptic Function<a class="headerlink" href="#elliptic-function" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.elljac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">elljac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.elljac" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jacobian elliptic functions <img class="math" src="_images/math/0e6b7dfd4cb3bb014eae6eb24180b03ad5f4edc2.png" alt="sn(u|m)"/>, <img class="math" src="_images/math/abd8fb620be825f9ec2d50b72b853908ad48f9d7.png" alt="cn(u|m)"/>, <img class="math" src="_images/math/2c9e944955b2e195e91e6e4f276dc75e2f51b135.png" alt="dn(u|m)"/> by descending Landen transformations.
It returns sn, cn and dn as:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">sn</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">elljac</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="error-functions">
<h3>Error Functions<a class="headerlink" href="#error-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.erf">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>The error function erf(x)</p>
<div class="math">
<p><img src="_images/math/5c83e786f1a74d55f2a9026b7a48775ab221cc68.png" alt="{2 \over \sqrt{\pi}} \int_0^x dt e^{-t^2}"/></p>
</div></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erfc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erfc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_erfc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the (logarithmic) complementary error function <img class="math" src="_images/math/48afacb0693f6c90d233a4d6d50e94013b94a55d.png" alt="erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erf_Q">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the upper tail of the Gaussian probability function <img class="math" src="_images/math/879a624406959fc96401be5bfc57bf586ad2ae52.png" alt="Q(x) = (1/\sqrt{2\pi}) \int_x^\infty dt \exp(-t^2/2"/></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.erf_Z">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">erf_Z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.erf_Z" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gaussian probability density function <img class="math" src="_images/math/28353a596c2d92c1c721c2033679953c1746636e.png" alt="Z(x) = (1/\sqrt{2\pi}) \exp(-x^2/2)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hazard">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hazard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hazard" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the hazard function for the normal distribution.</p>
</dd></dl>

</section>
<section id="exponential-functions">
<h3>Exponential Functions<a class="headerlink" href="#exponential-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.exp">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines provide an exponential function <img class="math" src="_images/math/7f6f9d7697a04d799007f832f65f31d71cc9b937.png" alt="\exp(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_err">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_err</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_err" title="Permalink to this definition">¶</a></dt>
<dd><p>This function exponentiates x with an associated absolute error dx.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_mult">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_mult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines exponentiate x and multiply by the factor y to return the product <img class="math" src="_images/math/164ff56eef5996116c7c35b7be379d72bdf63091.png" alt="y \exp(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exp_mult_err">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exp_mult_err</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exp_mult_err" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine computes the product <img class="math" src="_images/math/164ff56eef5996116c7c35b7be379d72bdf63091.png" alt="y \exp(x)"/> for the quantities x, y with associated absolute errors dx, dy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expm1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/0e5749950053d75aac4d05b9ac3da78ca4e099f1.png" alt="\exp(x)-1"/> using an algorithm that is accurate for small x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/69eb0e7e7a496064cfacb7fa929e9962efea2811.png" alt="(\exp(x)-1)/x"/> using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion <img class="math" src="_images/math/3cfd0ca0733fc74887c3425dfceb2365f4c1badc.png" alt="(\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \dots"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel_2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel_2" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/deaeb9f35ac209fac2a89d7d562af46ea6082b09.png" alt="2(\exp(x)-1-x)/x^2"/> using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion <img class="math" src="_images/math/43cfd5847390318e0709f3ce7cfcefe5d473862d.png" alt="2(\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \dots"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.exprel_n">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">exprel_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.exprel_n" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the N-relative exponential given by,</p>
<div class="math">
<p><img src="_images/math/da5f77ed16887915894deafcb3cfce64a87e36be.png" alt="exprel_N(x) = N!/x^N (\exp(x) - \sum_{k=0}^{N-1} x^k/k!)
            = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
            = 1F1 (1,1+N,x)"/></p>
</div></dd></dl>

</section>
<section id="exponential-integrals">
<h3>Exponential Integrals<a class="headerlink" href="#exponential-integrals" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_E">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_E</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_E" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the exponential integral <img class="math" src="_images/math/1867b2dad1f22ed741a90e2a0a2f0dfbd08c625f.png" alt="E_n(x)"/> of order n,</p>
<div class="math">
<p><img src="_images/math/ec145deb06d82cdab56b6ca82ec32833c2ee6f40.png" alt="E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n."/></p>
</div></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_Ei">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_Ei</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_Ei" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the exponential integral <img class="math" src="_images/math/af99e9e4303cebcc2451c294cbb0de9aa8460ffe.png" alt="Ei(x)"/>,</p>
<div class="math">
<p><img src="_images/math/14f317f574b24675d1f7942931b4ce568da965ff.png" alt="Ei(x) := - PV(\int_{-x}^\infty dt \exp(-t)/t)"/></p>
</div><p>where PV denotes the principal value of the integral.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Shi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Shi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Shi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the integral <img class="math" src="_images/math/54a71e53c791121accb1da9d2d0842168e165769.png" alt="Shi(x) = \int_0^x dt \sinh(t)/t"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Chi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Chi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the integral <img class="math" src="_images/math/5d0cb232c2bea4b603b3034488b5c8ded24fb704.png" alt="Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]"/> , where <img class="math" src="_images/math/4991f060ae5f244b0234eb28607b6e02db52296d.png" alt="\gamma_E"/> is the Euler constant (available as the macro M_EULER).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.expint_3">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">expint_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.expint_3" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the third-order exponential integral <img class="math" src="_images/math/ed63bc9b058d847d71b1f148924b6a4351085e75.png" alt="Ei_3(x) = \int_0^xdt \exp(-t^3)"/> for x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Si">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Si</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Si" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Sine integral <img class="math" src="_images/math/25a49964c536929b74dfff01d503df9b7cd5af04.png" alt="Si(x) = \int_0^x dt \sin(t)/t"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.Ci">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Ci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.Ci" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Cosine integral <img class="math" src="_images/math/d643047919349d56e74e1f8644c10bcfb196e6d2.png" alt="Ci(x) = -\int_x^\infty dt \cos(t)/t"/> for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.atanint">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">atanint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.atanint" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Arctangent integral, which is defined as <img class="math" src="_images/math/1e05395869f97f4a40121f02f4ea3d6317e512bd.png" alt="AtanInt(x) = \int_0^x dt \arctan(t)/t"/>.</p>
</dd></dl>

</section>
<section id="fermi-dirac-function">
<h3>Fermi Dirac Function<a class="headerlink" href="#fermi-dirac-function" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.fermi_dirac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fermi_dirac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fermi_dirac" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete Fermi-Dirac integral F<sub>n</sub>(x) is given by,</p>
<div class="math">
<p><img src="_images/math/761137d39ca431b3408b313f89c60740536e6074.png" alt="F_n(x) = {1 \over \Gamma(n+1)} \int_0^\infty dt {t^n \over e^{t-x} + 1}"/></p>
</div><p>Note that the Fermi-Dirac integral is sometimes defined without the normalization factor in other texts.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.fermi_dirac_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fermi_dirac_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fermi_dirac_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, <img class="math" src="_images/math/2fbbbd9397d8f72f9d2a2762d423d32b009f0c74.png" alt="F_0(x,b) = \ln(1 + e^{b-x}) - (b-x)"/>.</p>
<p>The incomplete Fermi-Dirac integral <img class="math" src="_images/math/a9c1e26ec3837d1d75c9e66032abc6723d670fb0.png" alt="F_j(x,b)"/> is given by,</p>
<div class="math">
<p><img src="_images/math/a2ba17ece40a3495e2a945db5e63781c0cfeed9e.png" alt="F_j(x,b)   := (1/\Gamma(j+1)) \int_b^\infty dt (t^j / (\exp(t-x) + 1))"/></p>
</div></dd></dl>

</section>
<section id="gamma-and-beta-functions">
<h3>Gamma and Beta Functions<a class="headerlink" href="#gamma-and-beta-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Shi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral <img class="math" src="_images/math/c5304b133c1699a433524c9c9d64fe2a38f9a6e3.png" alt="\textrm{Shi}(x) = \int_0^x dt \sinh(t)/t"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral</p>
<div class="math">
<p><img src="_images/math/20afd0b48bd3e8adc6d3b28eff3d48085acad434.png" alt="\textrm{Chi}(x) = \Re \left( \gamma_E +
\log(x) + \int_0^x dt \dfrac{\cosh(t)-1}{t} \right)"/></p>
</div><p>where γ<sub>E</sub> is the Euler constant.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id3">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Si</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Sine integral <img class="math" src="_images/math/713c85fb539a4b9c28d73c557c7c7fc3e23b73f5.png" alt="\textrm{Si}(x) = \int_0^x dt \dfrac{\sin(t)}{t}"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id4">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">Ci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cosine integral <img class="math" src="_images/math/ddf3c751ddb1c7f38f3b116b3a1c1c25829af7f6.png" alt="\textrm{Ci}(x) = -\int_x^\infty dt \dfrac{\cos(t)}{t}"/> for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id5">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">atanint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the Arctangent integral, which is defined as <img class="math" src="_images/math/9f1c98c7116ad939d2fc8db1651532b0fe20056c.png" alt="\textrm{AtanInt}(x) = \int_0^x dt \dfrac{\arctan(t)}{t}"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.fact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">fact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.fact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the factorial n!. The factorial is related to the Gamma function by <img class="math" src="_images/math/da68edcc3c25331020cc95549bdf7ebd09c25624.png" alt="n! = |Ggr| (n+1)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.doublefact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">doublefact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.doublefact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the double factorial <img class="math" src="_images/math/0e5651b293a0517fca3b724eac2aa2cc41446c15.png" alt="n!! = n(n-2)(n-4) \dots"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnfact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnfact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnfact" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the factorial of N, log(n!). The algorithm is faster than computing ln(Γ (n+1)).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lndoublefact">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lndoublefact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lndoublefact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of the double factorial of N, log(n!!).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.choose">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">choose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the combinatorial factor</p>
<div class="math">
<p><img src="_images/math/232530946bd3fde20af53d91bdcc907b8bc3b9f6.png" alt="\binom{n}{k} = \dfrac{n!}{k! (n-k)!}"/></p>
</div></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnchoose">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnchoose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnchoose" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of “n choose m”.  This is equivalent to the sum <img class="math" src="_images/math/859244d5fdc0661eabc71b89d26ecd53b48a2d9f.png" alt="\log(n!) - \log(m!) - \log((n-m)!)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Gamma function Γ (x), subject to x not being a negative integer or zero.  The function is computed using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lngamma">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lngamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lngamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of the Gamma function, <img class="math" src="_images/math/3e3ef6f75586cb1277814936b9b2a7f9316a29f0.png" alt="\log(\Gamma(x))"/>, subject to x not being a negative integer or zero.  For x&lt;0 the real part of <img class="math" src="_images/math/3e3ef6f75586cb1277814936b9b2a7f9316a29f0.png" alt="\log(\Gamma(x))"/> is returned, which  is equivalent to <img class="math" src="_images/math/cbac6a8c8b15c5137f481e14489633763cf93061.png" alt="\log(|\Gamma(x)|)"/>. The function is computed using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gammastar">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gammastar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gammastar" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regulated Gamma Function <img class="math" src="_images/math/e7f3e1f10ca92544e7cc5251b814b5d008108180.png" alt="\Gamma^*(x)"/> for x &gt; 0. The regulated gamma function is given by,</p>
<div class="math">
<p><img src="_images/math/5c61a8d6860526ce121e6d223bd27e20f55cc7f6.png" alt="\Gamma^*(x) = \Gamma(x)/(\sqrt{2\pi} x^{(x-1/2)} \exp(-x))

            = (1 + (1/12x) + ...)  for x \to \infty"/></p>
</div><p>and is a useful suggestion of Temme.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gammainv">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gammainv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gammainv" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the reciprocal of the gamma function, <img class="math" src="_images/math/d2410b2daef34584f51693eab57601e05f1be44c.png" alt="1/\Gamma(x)"/> using the real Lanczos method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lngammac">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lngammac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lngammac" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine computes <img class="math" src="_images/math/e6e34cbc0901d696f9c7aace24d4329df26f92dc.png" alt="\log(\Gamma(z))"/> for complex z and z not a negative integer or zero, using the complex Lanczos method.
The returned parameters are <img class="math" src="_images/math/f00fde58d106069a61f29637ff71cb573a15775d.png" alt="lnr = \log|\Gamma(z)|"/> and <img class="math" src="_images/math/4e2cf8b0620d253ef1f206027df63c55e8a5b87c.png" alt="arg = \arg(\Gamma(z)) in (-\pi,\pi]"/>.
Note that the phase part (arg) is not well-determined when <img class="math" src="_images/math/2c65f3f39964e03f56c80cd131cc3ea19419e211.png" alt="|z|"/> is very large, due to inevitable roundoff in restricting to (-pi,pi]. This will result in a GSL_ELOSS error when it occurs. The absolute value part (lnr), however, never suffers from loss of precision.</p>
<p>The functions returns:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">lnr</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">lngammac</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.beta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Beta Function, <img class="math" src="_images/math/e5c888a89c0594f279a82293e93bf86c72d39244.png" alt="B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b)"/> subject to a and b not being negative integers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnbeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnbeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnbeta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the Beta Function, <img class="math" src="_images/math/35f554b49d7c3feff2888dd338ab6824fb800e56.png" alt="\log(B(a,b))"/> subject to a and b not being negative integers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.beta_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">beta_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.beta_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized incomplete Beta function <img class="math" src="_images/math/a88b5dca92d49977ab9ba7bd18051e78f6f60d14.png" alt="I_x(a,b)=B_x(a,b)/B(a,b)"/> where <img class="math" src="_images/math/97b5455b54ef0a4eba8813d43fa2b18da496ddb7.png" alt="B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt"/> for 0 &lt;= x &lt;= 1.
For a &gt; 0, b &gt; 0 the value is computed using a continued fraction expansion. For all other values it is computed using the relation <img class="math" src="_images/math/07724f4cd4424fc2643614a5a3ad105a047ccb13.png" alt="I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.taylorcoeff">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">taylorcoeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.taylorcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Taylor coefficient <img class="math" src="_images/math/27bcf0cbb8c9aa7e743b79dd61ccbfcccce00782.png" alt="x^n / n!"/> for x &gt;= 0, n &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.poch">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">poch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.poch" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Pochhammer symbol <img class="math" src="_images/math/009bc6915549ddf5657ede234c86f9c2c07de09b.png" alt="(a)_x = \Gamma(a + x)/\Gamma(a)"/>. The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x). When a and a+x are negative integers or zero, the limiting value of the ratio is returned.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lnpoch">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lnpoch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lnpoch" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the Pochhammer symbol, <img class="math" src="_images/math/b7937d464c75bb2e87a6f24b2e54bb7af21e3299.png" alt="\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a))"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.pochrel">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">pochrel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.pochrel" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the relative Pochhammer symbol <img class="math" src="_images/math/b0793f6647588fb0db8c8918ea10c6e698ca56c1.png" alt="((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions compute the unnormalized incomplete Gamma Function <img class="math" src="_images/math/07b3f7a9d2199208d6fa5286614ce7c04d1cf947.png" alt="\Gamma(a,x) = \int_x^\infty dt t^{a-1} \exp(-t)"/> for a real and x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc_Q">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized incomplete Gamma Function <img class="math" src="_images/math/630db0d61a7ed86169c181e2708b8e8fe4d3387f.png" alt="Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^{a-1} \exp(-t)"/> for a &gt; 0, x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.gamma_inc_P">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gamma_inc_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gamma_inc_P" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the complementary normalized incomplete Gamma Function <img class="math" src="_images/math/5d7fce82adf68a8861c293f4aee9a6d861d60ae5.png" alt="P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^{a-1} \exp(-t)"/>
for a &gt; 0, x &gt;= 0. Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma function (section 6.5).</p>
</dd></dl>

</section>
<section id="gegenbauer-functions">
<h3>Gegenbauer Functions<a class="headerlink" href="#gegenbauer-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.gegenpoly">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">gegenpoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.gegenpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions evaluate the Gegenbauer polynomial <img class="math" src="_images/math/a52059ffbc797506196799199d345a28fe9b775b.png" alt="C^{(\lambda)}_n(x)"/>
for a specific value of n, lambda, x subject to <img class="math" src="_images/math/5b13d8ebf44900b0ed87b60255f66655b5c6e6b4.png" alt="\lambda &gt; -1/2"/>, n &gt;= 0.</p>
</dd></dl>

</section>
<section id="hypergeometric-functions">
<h3>Hypergeometric functions<a class="headerlink" href="#hypergeometric-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg0F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg0F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg0F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the hypergeometric function <img class="math" src="_images/math/8e9b36412330bbec7a7ec949607bd13579ce79d3.png" alt="0F1(c,x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg1F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg1F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg1F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the confluent hypergeometric function <img class="math" src="_images/math/8ce85ff1b811fe1b698fc9cc254aaf8b52d8bd45.png" alt="1F1(m,n,x) = M(m,n,x)"/>. The parameters m and n can be integer or real numbers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hypergU">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hypergU</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hypergU" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the confluent hypergeometric function <img class="math" src="_images/math/e8174f80ad237525108da536f3aebfe0639e5c1d.png" alt="U(m,n,x)"/>. The parameters m and n can be integer or real numbers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg2F1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg2F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg2F1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gauss hypergeometric function <img class="math" src="_images/math/e7f706beba80f792ac12442e05bfa042fb701059.png" alt="2F1(a,b,c,x) = F(a,b,c,x)"/> for <img class="math" src="_images/math/7d21309c9f1eec3b7a35c6beffe33bc2e824ae62.png" alt="|x| &lt; 1"/>.</p>
<p>If the arguments (a,b,c,x) are too close to a singularity then the function can return the error code <code class="docutils literal notranslate"><span class="pre">GSL_EMAXITER</span></code> when the series approximation converges too slowly.
This occurs in the region of x=1, c - a - b = m for integer m.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hyperg2F1conj">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hyperg2F1conj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hyperg2F1conj" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Gauss hypergeometric function <img class="math" src="_images/math/71f01e41238811bb5c2f8fbed00d1d32a92808c3.png" alt="2F1(a, a^*, c, x)"/> where a is complex parameter, c and x are real parameters with <img class="math" src="_images/math/7d21309c9f1eec3b7a35c6beffe33bc2e824ae62.png" alt="|x| &lt; 1"/>.</p>
</dd></dl>

</section>
<section id="laguerre-functions">
<h3>Laguerre Functions<a class="headerlink" href="#laguerre-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.laguerre">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">laguerre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.laguerre" title="Permalink to this definition">¶</a></dt>
<dd><p>The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as</p>
<div class="math">
<p><img src="_images/math/9fe1173459a66fa7dbcd54baa20eb89f83b44c58.png" alt="L^a_n(x) = {(a+1)_n \over n!} {}_1 F_1(-n,a+1,x)"/></p>
</div><p>and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials <img class="math" src="_images/math/3d66b6f1c06f1e950c50b4d42ee1cc3249f75457.png" alt="L_n(x)"/> by</p>
<div class="math">
<p><img src="_images/math/44c11cb0f8cb5f93077af269f1791b9ff5c53ec7.png" alt="L^0_n(x) = L_n(x)"/></p>
</div><p>and</p>
<div class="math">
<p><img src="_images/math/a0dde21cd15f7c5d25842e848970feb298dec88d.png" alt="L^k_n(x) = (-1)^k {d^k \over dx^k} L_{n+k}(x)"/></p>
</div><p>For more information see Abramowitz &amp; Stegun, Chapter 22.</p>
</dd></dl>

</section>
<section id="lambert-w-functions">
<h3>Lambert W Functions<a class="headerlink" href="#lambert-w-functions" title="Permalink to this heading">¶</a></h3>
<p>Lambert’s W functions, W(x), are defined to be solutions of the equation <img class="math" src="_images/math/12b1c6a43e61bd1c1f4d86c258fec2c387d9c28a.png" alt="W(x) \exp(W(x)) = x"/>.
This function has multiple branches for x &lt; 0; however, it has only two real-valued branches.
We define <img class="math" src="_images/math/b4d3eb740eb9f9fc8514b4f6d4206b8e6b1f77bc.png" alt="W_0(x)"/> to be the principal branch, where W &gt; -1 for x &lt; 0, and <img class="math" src="_images/math/be583c4ec304eab61d05f953216d0eaee7cce192.png" alt="W_{-1}(x)"/> to be the other real branch, where W &lt; -1 for x &lt; 0.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.lambertW0">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lambertW0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lambertW0" title="Permalink to this definition">¶</a></dt>
<dd><p>These compute the principal branch of the Lambert W function, <img class="math" src="_images/math/b4d3eb740eb9f9fc8514b4f6d4206b8e6b1f77bc.png" alt="W_0(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.lambertWm1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">lambertWm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.lambertWm1" title="Permalink to this definition">¶</a></dt>
<dd><p>These compute the secondary real-valued branch of the Lambert W function, <img class="math" src="_images/math/be583c4ec304eab61d05f953216d0eaee7cce192.png" alt="W_{-1}(x)"/>.</p>
</dd></dl>

</section>
<section id="legendre-functions-and-spherical-harmonics">
<h3>Legendre Functions and Spherical Harmonics<a class="headerlink" href="#legendre-functions-and-spherical-harmonics" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.legendreP">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendreP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendreP" title="Permalink to this definition">¶</a></dt>
<dd><figure class="align-default" id="id9">
<img alt="_images/examples-legendre-polynomials.png" src="_images/examples-legendre-polynomials.png" />
<figcaption>
<p><span class="caption-text">Legendre polynomials</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>These functions evaluate the Legendre polynomial <img class="math" src="_images/math/4d7d3920ea09efd8ffb80cfc55679d50594a0c97.png" alt="P_l(x)"/> for a specific value of l, x subject to l &gt;= 0, <img class="math" src="_images/math/75ef653e1051860111bbdf29d95f229db82cead1.png" alt="|x| &lt;= 1"/></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendreQ">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendreQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendreQ" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Legendre function <img class="math" src="_images/math/6066965805cb1d9ffb9da5ced1c06ed196044bb5.png" alt="Q_l(x)"/> for x &gt; -1, x != 1 and l &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendrePlm">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendrePlm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendrePlm" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the associated Legendre polynomial <img class="math" src="_images/math/6eff823f1d12bfeee0b413299e29e874eeffbebb.png" alt="P_l^m(x)"/> for m &gt;= 0, l &gt;= m, <img class="math" src="_images/math/75ef653e1051860111bbdf29d95f229db82cead1.png" alt="|x| &lt;= 1"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendresphPlm">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendresphPlm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendresphPlm" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the normalized associated Legendre polynomial <img class="math" src="_images/math/845a72fbaaeff6f8c2f47f9fd0b8b1e28fb3378e.png" alt="\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)!/(l+m)!} P_l^m(x)"/> suitable for use in spherical harmonics. The parameters must satisfy m &gt;= 0, l &gt;= m, <img class="math" src="_images/math/75ef653e1051860111bbdf29d95f229db82cead1.png" alt="|x| &lt;= 1"/>. Theses routines avoid the overflows that occur for the standard normalization of <img class="math" src="_images/math/6eff823f1d12bfeee0b413299e29e874eeffbebb.png" alt="P_l^m(x)"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalP">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalP" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the regular Spherical Conical Function <img class="math" src="_images/math/848371668666ce2eb9f393a41e451ce855a6c56c.png" alt="P^{n}_{-1/2 + i \lambda}(x)"/> for x &gt; -1 where n in {-12, 0, 12, 1}</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalPsphreg">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalPsphreg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalPsphreg" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Regular Spherical Conical Function <img class="math" src="_images/math/2f5e39b54b55b1e2d8b96144d7fc80ee89c1cf4f.png" alt="P^{-1/2-l}_{-1/2 + i \lambda}(x)"/> for x &gt; -1, l &gt;= -1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.conicalPcylreg">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">conicalPcylreg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.conicalPcylreg" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Regular Cylindrical Conical Function <img class="math" src="_images/math/9e5be46e066550b9174f9bd0e50bea67b72326a6.png" alt="P^{-m}_{-1/2 + i \lambda}(x)"/> for x &gt; -1, m &gt;= -1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.legendre_H3d">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">legendre_H3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.legendre_H3d" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space <img class="math" src="_images/math/de66b701f077922ac433f46983452edfb11b9587.png" alt="\eta &gt;= 0"/>, l &gt;= 0. In the flat limit this takes the form <img class="math" src="_images/math/0fee6149851d15b2493774abde2c13b4eb545e4b.png" alt="L^{H3d}_l(\lambda,\eta) = j_l(\lambda\eta)"/>.</p>
</dd></dl>

</section>
<section id="logarithm-and-related-functions">
<h3>Logarithm and Related Functions<a class="headerlink" href="#logarithm-and-related-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.log">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of x, <img class="math" src="_images/math/1ccbca93509ccde514f0d10f59570b9583f2532d.png" alt="\log(x)"/>, for x &gt; 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_abs">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the logarithm of the magnitude of x, <img class="math" src="_images/math/5689b2b89e709271c77b4cb9bb41208b2f94961b.png" alt="\log(|x|)"/>, for x ne 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_1plusx">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_1plusx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_1plusx" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute <img class="math" src="_images/math/edf8267eb08f1d4600c0443ab5226174ce65823c.png" alt="\log(1 + x)"/> for x &gt; -1 using an algorithm that is accurate for small x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.log_1plusx_mx">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">log_1plusx_mx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.log_1plusx_mx" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute <img class="math" src="_images/math/06a10344db1f01714e0e237933371b0f7b4ec242.png" alt="\log(1 + x) - x"/> for x &gt; -1 using an algorithm that is accurate for small x.</p>
</dd></dl>

</section>
<section id="psi-digamma-functions">
<h3>Psi (Digamma) Functions<a class="headerlink" href="#psi-digamma-functions" title="Permalink to this heading">¶</a></h3>
<p>The polygamma functions of order n are defined by</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/1e1c868b8078fd38e71d4906d7254b6674d0cb07.png" alt="\psi^{(n)}(x) = (d/dx)^n \psi(x) = (d/dx)^{n+1} \log(\Gamma(x))"/></p>
</div></div></blockquote>
<p>where <img class="math" src="_images/math/05d7bcf36cf9a7c5adb63b541f6b5772b60acc14.png" alt="\psi(x) = \Gamma'(x)/\Gamma(x)"/> is known as the digamma function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.psi">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the digamma function <img class="math" src="_images/math/a0474e9105013b044485f5d468f39bf8ac4d603d.png" alt="\psi(x)"/> for general x, x ne 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.psi_1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi_1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Trigamma function <img class="math" src="_images/math/2ea22bb4d69b5bb3ce140bbf36816152dad565b6.png" alt="\psi'(x)"/> for general x.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.1piy">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">1piy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.1piy" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the real part of the digamma function on the line 1+i y, <img class="math" src="_images/math/7abf6a3dbff4862ec9def6218bfc4edd4cbfead7.png" alt="\Re[\psi(1 + i y)]"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.psi_n">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">psi_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.psi_n" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the polygamma function <img class="math" src="_images/math/2c27d80c7b3fed5e1a83f8fbe363a3740e99b35b.png" alt="\psi^{(n)}(x)"/> for n &gt;= 0, x &gt; 0.</p>
</dd></dl>

</section>
<section id="synchrotron-functions">
<h3>Synchrotron Functions<a class="headerlink" href="#synchrotron-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.synchrotron1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">synchrotron1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.synchrotron1" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the first synchrotron function <img class="math" src="_images/math/e86e50530d66f823d4e2107cac9d4740c1b8bbcb.png" alt="x \int_x^\infty dt K_{5/3}(t)"/> for x &gt;= 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.synchrotron2">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">synchrotron2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.synchrotron2" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the second synchrotron function <img class="math" src="_images/math/650eaff2703f025a25dbac33afac7487f1744cf7.png" alt="x K_{2/3}(x)"/> for x &gt;= 0.</p>
</dd></dl>

</section>
<section id="transport-functions">
<h3>Transport Functions<a class="headerlink" href="#transport-functions" title="Permalink to this heading">¶</a></h3>
<p>The transport functions J(n,x) are defined by the integral representations <img class="math" src="_images/math/f5ae4517596d704cf1c48f59bad20b9788f5b4f1.png" alt="J(n,x) := \int_0^x dt t^n e^t /(e^t - 1)^2"/>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sf.transport">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the transport function <img class="math" src="_images/math/8d7ca252fb09ab824de4eaa181e57da8de68edb3.png" alt="J(n,x)"/> with <img class="math" src="_images/math/a69003862adaadd05808199daddc5a6d045cb2fa.png" alt="n \in {2,3,4,5}"/></p>
</dd></dl>

</section>
<section id="zeta-functions">
<h3>Zeta Functions<a class="headerlink" href="#zeta-functions" title="Permalink to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sf.zeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>The Riemann zeta function is defined by the infinite sum <img class="math" src="_images/math/a6fca9b1ea74fc7adb6f6aebaafaeee8bfe62003.png" alt="\zeta(s) = \sum_{k=1}^\infty k^{-s}"/>.
These routines compute the Riemann zeta function <img class="math" src="_images/math/1d903f91afe41e04046da43e5a4b06f82909dd51.png" alt="\zeta(s)"/> for arbitrary s, <img class="math" src="_images/math/2c2a5c8b064fb10c341c5c3c0d4359c969f6eda6.png" alt="s \ne 1"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.zetam1">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">zetam1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.zetam1" title="Permalink to this definition">¶</a></dt>
<dd><p>For large positive argument, the Riemann zeta function approaches one. In this region the fractional part is interesting, and therefore we need a function to evaluate it explicitly.
These routines compute <img class="math" src="_images/math/ad4e710d900f2754ef80f06c1ccf457b2f09ee14.png" alt="\zeta(s) - 1"/> for arbitrary s, <img class="math" src="_images/math/2c2a5c8b064fb10c341c5c3c0d4359c969f6eda6.png" alt="s \ne 1"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.eta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">eta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>The eta function is defined by <img class="math" src="_images/math/2ff3066c560b5e5e555995a72d9e992c5217a4c4.png" alt="\eta(s) = (1-2^{1-s}) \zeta(s)"/>.
These routines compute the eta function eta(s) for arbitrary s.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sf.hzeta">
<span class="sig-prename descclassname"><span class="pre">sf.</span></span><span class="sig-name descname"><span class="pre">hzeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sf.hzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>These routines compute the Hurwitz zeta function <img class="math" src="_images/math/116ddce24d1a37f24a53cdc02e434498d9f9e137.png" alt="\zeta(s,q)"/> for s &gt; 1, q &gt; 0.</p>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Special functions</a><ul>
<li><a class="reference internal" href="#module-sf">Overview</a><ul>
<li><a class="reference internal" href="#airy-functions">Airy Functions</a><ul>
<li><a class="reference internal" href="#sf.airyAi"><code class="docutils literal notranslate"><span class="pre">airyAi()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi"><code class="docutils literal notranslate"><span class="pre">airyBi()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyAi_scaled"><code class="docutils literal notranslate"><span class="pre">airyAi_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi_scaled"><code class="docutils literal notranslate"><span class="pre">airyBi_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyAi_deriv"><code class="docutils literal notranslate"><span class="pre">airyAi_deriv()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyAi_deriv_scaled"><code class="docutils literal notranslate"><span class="pre">airyAi_deriv_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi_deriv"><code class="docutils literal notranslate"><span class="pre">airyBi_deriv()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi_deriv_scaled"><code class="docutils literal notranslate"><span class="pre">airyBi_deriv_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyAi_zero"><code class="docutils literal notranslate"><span class="pre">airyAi_zero()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyAi_deriv_zero"><code class="docutils literal notranslate"><span class="pre">airyAi_deriv_zero()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi_zero"><code class="docutils literal notranslate"><span class="pre">airyBi_zero()</span></code></a></li>
<li><a class="reference internal" href="#sf.airyBi_deriv_zero"><code class="docutils literal notranslate"><span class="pre">airyBi_deriv_zero()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#bessel-functions">Bessel Functions</a><ul>
<li><a class="reference internal" href="#sf.besselJ"><code class="docutils literal notranslate"><span class="pre">besselJ()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselJ_zero"><code class="docutils literal notranslate"><span class="pre">besselJ_zero()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselY"><code class="docutils literal notranslate"><span class="pre">besselY()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselYnu"><code class="docutils literal notranslate"><span class="pre">besselYnu()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselI"><code class="docutils literal notranslate"><span class="pre">besselI()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselI_scaled"><code class="docutils literal notranslate"><span class="pre">besselI_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselInu"><code class="docutils literal notranslate"><span class="pre">besselInu()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselInu_scaled"><code class="docutils literal notranslate"><span class="pre">besselInu_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselK"><code class="docutils literal notranslate"><span class="pre">besselK()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselK_scaled"><code class="docutils literal notranslate"><span class="pre">besselK_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselKnu"><code class="docutils literal notranslate"><span class="pre">besselKnu()</span></code></a></li>
<li><a class="reference internal" href="#sf.bessellnKnu"><code class="docutils literal notranslate"><span class="pre">bessellnKnu()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselKnu_scaled"><code class="docutils literal notranslate"><span class="pre">besselKnu_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselj"><code class="docutils literal notranslate"><span class="pre">besselj()</span></code></a></li>
<li><a class="reference internal" href="#sf.bessely"><code class="docutils literal notranslate"><span class="pre">bessely()</span></code></a></li>
<li><a class="reference internal" href="#sf.besseli_scaled"><code class="docutils literal notranslate"><span class="pre">besseli_scaled()</span></code></a></li>
<li><a class="reference internal" href="#sf.besselk"><code class="docutils literal notranslate"><span class="pre">besselk()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#clausen-function">Clausen Function</a><ul>
<li><a class="reference internal" href="#sf.clausen"><code class="docutils literal notranslate"><span class="pre">clausen()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#coulomb-functions">Coulomb Functions</a><ul>
<li><a class="reference internal" href="#sf.hydrogenicR_1"><code class="docutils literal notranslate"><span class="pre">hydrogenicR_1()</span></code></a></li>
<li><a class="reference internal" href="#sf.hydrogenicR"><code class="docutils literal notranslate"><span class="pre">hydrogenicR()</span></code></a></li>
<li><a class="reference internal" href="#sf.coulomb_wave_FG"><code class="docutils literal notranslate"><span class="pre">coulomb_wave_FG()</span></code></a></li>
<li><a class="reference internal" href="#sf.coulomb_CL"><code class="docutils literal notranslate"><span class="pre">coulomb_CL()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#coupling-coefficients">Coupling Coefficients</a><ul>
<li><a class="reference internal" href="#sf.coupling_3j"><code class="docutils literal notranslate"><span class="pre">coupling_3j()</span></code></a></li>
<li><a class="reference internal" href="#sf.coupling_6j"><code class="docutils literal notranslate"><span class="pre">coupling_6j()</span></code></a></li>
<li><a class="reference internal" href="#sf.coupling_9j"><code class="docutils literal notranslate"><span class="pre">coupling_9j()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#dawson-function">Dawson Function</a><ul>
<li><a class="reference internal" href="#sf.dawson"><code class="docutils literal notranslate"><span class="pre">dawson()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#debye-functions">Debye Functions</a><ul>
<li><a class="reference internal" href="#sf.debye"><code class="docutils literal notranslate"><span class="pre">debye()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#dilogarithms">Dilogarithms</a><ul>
<li><a class="reference internal" href="#sf.dilog"><code class="docutils literal notranslate"><span class="pre">dilog()</span></code></a></li>
<li><a class="reference internal" href="#sf.cdilog"><code class="docutils literal notranslate"><span class="pre">cdilog()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#elliptic-integrals">Elliptic Integrals</a><ul>
<li><a class="reference internal" href="#sf.ellint_D"><code class="docutils literal notranslate"><span class="pre">ellint_D()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_E"><code class="docutils literal notranslate"><span class="pre">ellint_E()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_F"><code class="docutils literal notranslate"><span class="pre">ellint_F()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_P"><code class="docutils literal notranslate"><span class="pre">ellint_P()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_RC"><code class="docutils literal notranslate"><span class="pre">ellint_RC()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_RD"><code class="docutils literal notranslate"><span class="pre">ellint_RD()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_RF"><code class="docutils literal notranslate"><span class="pre">ellint_RF()</span></code></a></li>
<li><a class="reference internal" href="#sf.ellint_RJ"><code class="docutils literal notranslate"><span class="pre">ellint_RJ()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#elliptic-function">Elliptic Function</a><ul>
<li><a class="reference internal" href="#sf.elljac"><code class="docutils literal notranslate"><span class="pre">elljac()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-functions">Error Functions</a><ul>
<li><a class="reference internal" href="#sf.erf"><code class="docutils literal notranslate"><span class="pre">erf()</span></code></a></li>
<li><a class="reference internal" href="#sf.erfc"><code class="docutils literal notranslate"><span class="pre">erfc()</span></code></a></li>
<li><a class="reference internal" href="#sf.log_erfc"><code class="docutils literal notranslate"><span class="pre">log_erfc()</span></code></a></li>
<li><a class="reference internal" href="#sf.erf_Q"><code class="docutils literal notranslate"><span class="pre">erf_Q()</span></code></a></li>
<li><a class="reference internal" href="#sf.erf_Z"><code class="docutils literal notranslate"><span class="pre">erf_Z()</span></code></a></li>
<li><a class="reference internal" href="#sf.hazard"><code class="docutils literal notranslate"><span class="pre">hazard()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#exponential-functions">Exponential Functions</a><ul>
<li><a class="reference internal" href="#sf.exp"><code class="docutils literal notranslate"><span class="pre">exp()</span></code></a></li>
<li><a class="reference internal" href="#sf.exp_err"><code class="docutils literal notranslate"><span class="pre">exp_err()</span></code></a></li>
<li><a class="reference internal" href="#sf.exp_mult"><code class="docutils literal notranslate"><span class="pre">exp_mult()</span></code></a></li>
<li><a class="reference internal" href="#sf.exp_mult_err"><code class="docutils literal notranslate"><span class="pre">exp_mult_err()</span></code></a></li>
<li><a class="reference internal" href="#sf.expm1"><code class="docutils literal notranslate"><span class="pre">expm1()</span></code></a></li>
<li><a class="reference internal" href="#sf.exprel"><code class="docutils literal notranslate"><span class="pre">exprel()</span></code></a></li>
<li><a class="reference internal" href="#sf.exprel_2"><code class="docutils literal notranslate"><span class="pre">exprel_2()</span></code></a></li>
<li><a class="reference internal" href="#sf.exprel_n"><code class="docutils literal notranslate"><span class="pre">exprel_n()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#exponential-integrals">Exponential Integrals</a><ul>
<li><a class="reference internal" href="#sf.expint_E"><code class="docutils literal notranslate"><span class="pre">expint_E()</span></code></a></li>
<li><a class="reference internal" href="#sf.expint_Ei"><code class="docutils literal notranslate"><span class="pre">expint_Ei()</span></code></a></li>
<li><a class="reference internal" href="#sf.Shi"><code class="docutils literal notranslate"><span class="pre">Shi()</span></code></a></li>
<li><a class="reference internal" href="#sf.Chi"><code class="docutils literal notranslate"><span class="pre">Chi()</span></code></a></li>
<li><a class="reference internal" href="#sf.expint_3"><code class="docutils literal notranslate"><span class="pre">expint_3()</span></code></a></li>
<li><a class="reference internal" href="#sf.Si"><code class="docutils literal notranslate"><span class="pre">Si()</span></code></a></li>
<li><a class="reference internal" href="#sf.Ci"><code class="docutils literal notranslate"><span class="pre">Ci()</span></code></a></li>
<li><a class="reference internal" href="#sf.atanint"><code class="docutils literal notranslate"><span class="pre">atanint()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fermi-dirac-function">Fermi Dirac Function</a><ul>
<li><a class="reference internal" href="#sf.fermi_dirac"><code class="docutils literal notranslate"><span class="pre">fermi_dirac()</span></code></a></li>
<li><a class="reference internal" href="#sf.fermi_dirac_inc"><code class="docutils literal notranslate"><span class="pre">fermi_dirac_inc()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#gamma-and-beta-functions">Gamma and Beta Functions</a><ul>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">Shi()</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">Chi()</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">Si()</span></code></a></li>
<li><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">Ci()</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">atanint()</span></code></a></li>
<li><a class="reference internal" href="#sf.fact"><code class="docutils literal notranslate"><span class="pre">fact()</span></code></a></li>
<li><a class="reference internal" href="#sf.doublefact"><code class="docutils literal notranslate"><span class="pre">doublefact()</span></code></a></li>
<li><a class="reference internal" href="#sf.lnfact"><code class="docutils literal notranslate"><span class="pre">lnfact()</span></code></a></li>
<li><a class="reference internal" href="#sf.lndoublefact"><code class="docutils literal notranslate"><span class="pre">lndoublefact()</span></code></a></li>
<li><a class="reference internal" href="#sf.choose"><code class="docutils literal notranslate"><span class="pre">choose()</span></code></a></li>
<li><a class="reference internal" href="#sf.lnchoose"><code class="docutils literal notranslate"><span class="pre">lnchoose()</span></code></a></li>
<li><a class="reference internal" href="#sf.gamma"><code class="docutils literal notranslate"><span class="pre">gamma()</span></code></a></li>
<li><a class="reference internal" href="#sf.lngamma"><code class="docutils literal notranslate"><span class="pre">lngamma()</span></code></a></li>
<li><a class="reference internal" href="#sf.gammastar"><code class="docutils literal notranslate"><span class="pre">gammastar()</span></code></a></li>
<li><a class="reference internal" href="#sf.gammainv"><code class="docutils literal notranslate"><span class="pre">gammainv()</span></code></a></li>
<li><a class="reference internal" href="#sf.lngammac"><code class="docutils literal notranslate"><span class="pre">lngammac()</span></code></a></li>
<li><a class="reference internal" href="#sf.beta"><code class="docutils literal notranslate"><span class="pre">beta()</span></code></a></li>
<li><a class="reference internal" href="#sf.lnbeta"><code class="docutils literal notranslate"><span class="pre">lnbeta()</span></code></a></li>
<li><a class="reference internal" href="#sf.beta_inc"><code class="docutils literal notranslate"><span class="pre">beta_inc()</span></code></a></li>
<li><a class="reference internal" href="#sf.taylorcoeff"><code class="docutils literal notranslate"><span class="pre">taylorcoeff()</span></code></a></li>
<li><a class="reference internal" href="#sf.poch"><code class="docutils literal notranslate"><span class="pre">poch()</span></code></a></li>
<li><a class="reference internal" href="#sf.lnpoch"><code class="docutils literal notranslate"><span class="pre">lnpoch()</span></code></a></li>
<li><a class="reference internal" href="#sf.pochrel"><code class="docutils literal notranslate"><span class="pre">pochrel()</span></code></a></li>
<li><a class="reference internal" href="#sf.gamma_inc"><code class="docutils literal notranslate"><span class="pre">gamma_inc()</span></code></a></li>
<li><a class="reference internal" href="#sf.gamma_inc_Q"><code class="docutils literal notranslate"><span class="pre">gamma_inc_Q()</span></code></a></li>
<li><a class="reference internal" href="#sf.gamma_inc_P"><code class="docutils literal notranslate"><span class="pre">gamma_inc_P()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#gegenbauer-functions">Gegenbauer Functions</a><ul>
<li><a class="reference internal" href="#sf.gegenpoly"><code class="docutils literal notranslate"><span class="pre">gegenpoly()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hypergeometric-functions">Hypergeometric functions</a><ul>
<li><a class="reference internal" href="#sf.hyperg0F1"><code class="docutils literal notranslate"><span class="pre">hyperg0F1()</span></code></a></li>
<li><a class="reference internal" href="#sf.hyperg1F1"><code class="docutils literal notranslate"><span class="pre">hyperg1F1()</span></code></a></li>
<li><a class="reference internal" href="#sf.hypergU"><code class="docutils literal notranslate"><span class="pre">hypergU()</span></code></a></li>
<li><a class="reference internal" href="#sf.hyperg2F1"><code class="docutils literal notranslate"><span class="pre">hyperg2F1()</span></code></a></li>
<li><a class="reference internal" href="#sf.hyperg2F1conj"><code class="docutils literal notranslate"><span class="pre">hyperg2F1conj()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#laguerre-functions">Laguerre Functions</a><ul>
<li><a class="reference internal" href="#sf.laguerre"><code class="docutils literal notranslate"><span class="pre">laguerre()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lambert-w-functions">Lambert W Functions</a><ul>
<li><a class="reference internal" href="#sf.lambertW0"><code class="docutils literal notranslate"><span class="pre">lambertW0()</span></code></a></li>
<li><a class="reference internal" href="#sf.lambertWm1"><code class="docutils literal notranslate"><span class="pre">lambertWm1()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#legendre-functions-and-spherical-harmonics">Legendre Functions and Spherical Harmonics</a><ul>
<li><a class="reference internal" href="#sf.legendreP"><code class="docutils literal notranslate"><span class="pre">legendreP()</span></code></a></li>
<li><a class="reference internal" href="#sf.legendreQ"><code class="docutils literal notranslate"><span class="pre">legendreQ()</span></code></a></li>
<li><a class="reference internal" href="#sf.legendrePlm"><code class="docutils literal notranslate"><span class="pre">legendrePlm()</span></code></a></li>
<li><a class="reference internal" href="#sf.legendresphPlm"><code class="docutils literal notranslate"><span class="pre">legendresphPlm()</span></code></a></li>
<li><a class="reference internal" href="#sf.conicalP"><code class="docutils literal notranslate"><span class="pre">conicalP()</span></code></a></li>
<li><a class="reference internal" href="#sf.conicalPsphreg"><code class="docutils literal notranslate"><span class="pre">conicalPsphreg()</span></code></a></li>
<li><a class="reference internal" href="#sf.conicalPcylreg"><code class="docutils literal notranslate"><span class="pre">conicalPcylreg()</span></code></a></li>
<li><a class="reference internal" href="#sf.legendre_H3d"><code class="docutils literal notranslate"><span class="pre">legendre_H3d()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#logarithm-and-related-functions">Logarithm and Related Functions</a><ul>
<li><a class="reference internal" href="#sf.log"><code class="docutils literal notranslate"><span class="pre">log()</span></code></a></li>
<li><a class="reference internal" href="#sf.log_abs"><code class="docutils literal notranslate"><span class="pre">log_abs()</span></code></a></li>
<li><a class="reference internal" href="#sf.log_1plusx"><code class="docutils literal notranslate"><span class="pre">log_1plusx()</span></code></a></li>
<li><a class="reference internal" href="#sf.log_1plusx_mx"><code class="docutils literal notranslate"><span class="pre">log_1plusx_mx()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#psi-digamma-functions">Psi (Digamma) Functions</a><ul>
<li><a class="reference internal" href="#sf.psi"><code class="docutils literal notranslate"><span class="pre">psi()</span></code></a></li>
<li><a class="reference internal" href="#sf.psi_1"><code class="docutils literal notranslate"><span class="pre">psi_1()</span></code></a></li>
<li><a class="reference internal" href="#sf.1piy"><code class="docutils literal notranslate"><span class="pre">1piy()</span></code></a></li>
<li><a class="reference internal" href="#sf.psi_n"><code class="docutils literal notranslate"><span class="pre">psi_n()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchrotron-functions">Synchrotron Functions</a><ul>
<li><a class="reference internal" href="#sf.synchrotron1"><code class="docutils literal notranslate"><span class="pre">synchrotron1()</span></code></a></li>
<li><a class="reference internal" href="#sf.synchrotron2"><code class="docutils literal notranslate"><span class="pre">synchrotron2()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#transport-functions">Transport Functions</a><ul>
<li><a class="reference internal" href="#sf.transport"><code class="docutils literal notranslate"><span class="pre">transport()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#zeta-functions">Zeta Functions</a><ul>
<li><a class="reference internal" href="#sf.zeta"><code class="docutils literal notranslate"><span class="pre">zeta()</span></code></a></li>
<li><a class="reference internal" href="#sf.zetam1"><code class="docutils literal notranslate"><span class="pre">zetam1()</span></code></a></li>
<li><a class="reference internal" href="#sf.eta"><code class="docutils literal notranslate"><span class="pre">eta()</span></code></a></li>
<li><a class="reference internal" href="#sf.hzeta"><code class="docutils literal notranslate"><span class="pre">hzeta()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="integ.html"
                          title="previous chapter">Numerical Integration</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="vegas.html"
                          title="next chapter">Monte Carlo Integration</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/sf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vegas.html" title="Monte Carlo Integration"
             >next</a> |</li>
        <li class="right" >
          <a href="integ.html" title="Numerical Integration"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GSL Shell 2.3.6 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Special functions</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2023, Francesco Abbate.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>